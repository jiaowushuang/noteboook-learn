**网络是由节点间相互连接的链路组成的。**

1. 如何把两个节点连接在一起
2. 云的概念
3. 如何将一台主机连接到云{如何将多个节点连接到ISP云中}

**需要考虑的问题** 首先是需要选择合适连接的物理介质；其次是在节点间可以交换分组之前，必须解决以下问题：

网络体系结构（或是分层协议）：提供复杂链路的简单抽象，使不同的链路对于终端用户和路由器来说是一样的。{关键在于必须处理存在于现实世界的所有物理约束和链路缺陷}。

**连接策略**

五个基本问题：

1. 编码：对传输到介质上的比特编码，使其能被接受主机理解
2. 组帧：把在链路上传输的比特序列描述为完整的消息，以便传输到端节点{传输到端主机的消息称为帧，或是分组}
3. 差错检测：传输过程的帧可能会出错，故必须检测到这类差错并采取适当的行动
4. 可靠传输：虽然帧会出错，但是还是要建立一条看起来可靠的链路
5. 介质访问控制：在多台主机共享一条链路时，必须协调对该链路的访问{多路访问}

    介质访问协议

	1. 以太网协议{现今以太网链路多采用点对点形式，因此也不涉及介质访问控制一说}
	2. 无线协议

**在不同的网络技术中，是以不同方式来解决上述问题的。关注如何把各种不同的物理介质连接起来构造鲁棒性和可扩展俱佳的网络**

三种网络技术：

1. 点到点链路{不涉及第五个基本问题}
2. 载波监听/冲突检测多路访问网络{以太网}
3. 无线网络{802.11Wi-FI、蓝牙、3G/4G/5G蜂窝}

**编码（NRZ、NRZI、曼彻斯特、4B/5B）**

- NRZ：数值1对应高电平、数值0对应低电平。
	- 可能会导致一长串的0和1，进而产生以下两个问题：
	- 基线漂移：接收方计算所看到的信号的平均值，然后利用这个平均值来区分高低电平，即是否在误差容限内
	- 时钟恢复-自同步是依赖于很多跳变的（当信号出现从0到1或是从1到0的跳变时，便会自同步），相反若长时间不出现跳变，则会产生时钟漂/偏移
- NRZI：当前信号的跳变对应1，当前信号的保持对应0（显然未解决连续0的问题）
- 曼彻斯特：由低到高的跳变对应1，由高到低的跳变对应0{传输NRZ编码的数据与时钟的异或值}（?编码效率：比特率/波特率=50%{一长串0/1}）
- 4B/5B：在比特序列中插入额外的比特以打破一连串0/1。顾名思义就是使用5个比特来编码4个比特的数据，然后将得到的5比特代码使用NRZI编码传输。（5比特代码规则：每个代码最多有一个前导0，末端最多有两个0以解决长串0的问题）。（编码效率：80%）。2^5-2^4:控制符号以用于组帧。

**组帧：决定帧从哪里开始到哪里结束**

1. 面向字节的协议（BISYNC、PPP、DDCMP）：把每一帧看成一个字节（字符）集{起止标记法-字符填充法、Count计数字段指明帧的字节数}
2. 面向比特的协议（HDLC）：不关心字节的边界，只是把帧看成比特的集合。{起止标记法-比特填充法}
3. 基于时钟的组帧（SONET）：光网络远距离传输数据的主要标准

**差错检测：比特错**

检测只是问题的一部分，另一部分是一发现差错就立即纠错。

1. 通知发送方 消息受到破坏，使发送方重发消息的副本
2. 使接收方在即使消息出错后仍可以重新构造正确的消息{纠错码}

{纠错？检错}

1. 检错：会重发副本，可能导致带宽用尽且产生时延
2. 纠错：每个消息中都需要包含 检错码和纠错码
	1. 差错很有可能发生{无线 }
	2. 重传的代价太高{卫星链路上的重传时延}

差错检测的基本思想：在帧中加入冗余信息来确定是否存在差错。而冗余信息{差错检测码：其中检验和只是一种情况（使用求和算法）}则是用某种明确定义的算法直接从原始消息中导出信息。发送方和接收方使用相同的算法，比较经算法后的结果是否一致。

1. 二维奇偶校验{BISYNC协议传输ASCII码}
2. 因特网校验和{某些因特网协议}
3. 循环冗余校验CRC{BISYNC传输EBCDIC用CRC以及其他广泛的情况}

**可靠传输：由于某些差错帧必须丢弃{破坏严重；开销太大}：相应的需要实现一种机制来恢复它们**

到底应该在哪一层提供可靠传输依赖于很多因素；可靠传输的基本思想是可以跨层的{不仅适用于链路层或是传输层}
基本机制：

1. 确认（ACK）：协议发给它的对等实体的一个小的控制帧，告诉它已经收到刚才的帧。{只有当原始帧的发送方收到确认之后，方可表明帧发送成功}。
2. 超时：如果发送方在一段相当长的时间内未收到确认，那么便重传原始帧。等待一段相当长的时间的动作称为超时。

使用确认和超时实现可靠传输的策略称为自动请求重发（ARQ），以下是三种ARQ算法：

1. 停止-等待：
2. 滑动窗口：
3. 并发逻辑信道：

**以太网和多路访问网络**


**无线网络**













时间偏差：
> clockskew（时钟漂移），由于DCM-clocktree上的load不完全匹配（也不可能完全匹配）或physicaldesign(P&R)等原因，导致clock到达各个Flip-Flop的时间不一致，而这种时间上的偏差，通常是称之为clockskew，clockskew对于某一个确定的模块或完成physicaldesign来说是固定存在的，其值也是固定的（前一个clockcycle上，两个FF之间的clockskew和后一个clockcycle上的是一样的），所以，只要在设计中考虑这个，就可以避免，甚至可以利用clockskew来偷时间。

> clockjitter（时钟抖动），由于PLL的phaselock出现不确定因素问题，从而导致clock在某个时间点出现了偏差，从而导致到达两个FF的时钟有偏差。clockjitter与clockskew不一样就在于它是不确定的，不是每个clockcycle都存在，出现的时间点也不确定，在设计中无法避免它能带来的影响，通常只能在设计中留有一定的margin。

时间同步：
> 自同步{数据总线：由接收到的数据信号得到时钟（时钟恢复）}、源同步{数据总线：同时包含数据信号和时钟信号}、系统同步{数据总线和时钟信号线}

调查问卷：

1. 位同步：发送方和接收方（编码和解码）过程都由一个“时钟”来驱动的，每个时钟周期发送1bit，接收方恢复1bit{即：数据和时钟沿对上，发送和接收方的节奏步伐对上}。为了使接收方能恢复发送方的bit，发送方和接收方的时钟必须精确同步 并且单方的时钟、条件的输入、数据的输出必须满足建立时间和保持时间约束。
	1. 数字约束：找准时钟上升沿最为恰当的建立时间和保持时间分界点
	2. 发送和接受节奏 ?时钟同步:时间偏差
2. 字（比特序列）同步：通俗的讲，就是找准比特序列的首部。{即，D3D2D1D0：消息；D2D1D0D3：什么也不是}。
	1. 选择器件的模式{自我校正}
	2. 自定义帧头来作为比特序列的首部


> 曼彻斯特编码（Manchester Encoding），也叫做相位编码（ Phase Encode，简写PE），是一个同步时钟编码技术，被物理层使用来编码一个同步位流的时钟和数据。它在以太网媒介系统中的应用属于数据通信中的两种位同步方法里的自同步法（另一种是外同步法），即接收方利用包含有同步信号的特殊编码从信号自身提取同步信号来锁定自己的时钟脉冲频率，达到同步目的。曼彻斯特编码，常用于局域网传输。曼彻斯特编码将时钟和数据包含在数据流中，在传输代码信息的同时，也将时钟同步信号一起传输到对方，每位编码中有一跳变，不存在直流分量，因此具有自同步能力和良好的抗干扰性能。但每一个码元都被调成两个电平，所以数据传输速率只有调制速率的1/2。
> 
> Manchester码是一种用跳变沿（而非电平）来表示要传输的二进制信息（0或1），一般规定在位元中间用下跳变表示”1″，用上跳变表示”0″. 曼彻斯特编码被被认为是一种自定时码，自定时意味着数据流的精确同步是可行的。每一个比特都准确的在一预先定义时间时期的时间中被传送。
> 
> 曼彻斯特编码提供了一种简单的方法在长时间段内没有电平跳变的情况下，仍然能够对任意的二进制序列进行编码，并且防止在这种情况下同步时钟信号的丢失以及防止低通模拟电路中低频直流飘移所引起的比特错误。如果保证传送的编码交流信号的直流分量为零并且能够防止中继信号的基线漂移，那么很容易实现信号的恢复和防止能量的浪费。曼彻斯特码具有丰富的位定时信息。
  
> 比特率：比特传输的速率
> 波特率：信号变化的速率 

> 要传送 k 位信息码元，经过编码后得到长度为 n （n>k）的码字。增加的监督码元的数量为 r=n–k。
> 编码效率：Rc=k/n；而监督码元数 （n–k） 和信息码元数 k 之比 (n–k)/k 称为冗余度。

**TCP**

 1. Reliability ，TCP的传输要保证数据能够准确到达目的地，如果不能，需要能检测出来并且重新发送数据。

 2. Data Flow Control，提供TCP的流控特性，管理发送数据的速率，不要超过设备的承载能力。

因此，TCP实现了很多细节，比如：滑动窗口，超时重传，累积ACK等。

**滑动窗口**

IP层协议属于不可靠协议，IP层并不关心数据是否发送到了对端；TCP通过确认机制来保证数据传输的可靠性。

stop-wait模式：发送方在发送数据之后会启动定时器，但是如果数据或者ACK丢失，那么定时器到期之后，收不到ACK就认为发送出现状况，要进行重传。它的通信的效率不高。如下图所示，这种方式被称为 positive acknowledgment with retransmission (PAR)。

![](http://img.blog.csdn.net/20160905224437961)

滑动窗口的机制：

1. 若发送的每一帧都有一个序号，接收端必须对每一个帧进行确认；这样设备一次发送几个片段，而不必等候ACK。
2. 同时接收端也要告知它能够收多少，这样发送端发起来也有个限制。
3. 当然还需要保证顺序性，不要乱序。
4. 对于乱序的状况，我们可以允许等待，比如说先缓存提前到的数据，然后去等待需要的数据；如果一定时间（超时）没来就PASS掉，重传，再保证顺序性。

发送端数据类型：

1. Sent and Acknowledged：这些数据表示已经发送成功并已经被确认的数据，比如图中的前31个bytes。这些数据其实的位置是在窗口之外，因为窗口内顺序最低的被确认之后，要移动窗口；实际上是窗口向右滑动，同时发送新数据。

2. Send But Not Yet Acknowledged：这部分数据称为发送但没有被确认，数据被发送出去，没有收到接收端的ACK，认为并没有完成发送，这个属于窗口内的数据。

3. Not Sent，Recipient Ready to Receive：这部分是将要发送的数据，这部分数据已经被加载到缓存中，也就是窗口内，等待发送。其实这个窗口完全是由接收方告知的:接收方告知还是能够接受这些包，所以发送方需要尽快的发送这些包

4. Not Sent，Recipient Not Ready to Receive： 这些数据属于未发送，同时也是接收端不允许发送的。因为这些数据已经超出了发送端所接收的范围。

![](http://img.blog.csdn.net/20160906072310877)

对于发送方，窗口包括两部分：Already窗口（已经发送，但是没有收到ACK）以及Send窗口（接收端允许发送但是没有发送的那部分）。

1. Send Window ： 20个bytes 这部分值是有接收方在三次握手的时候进行通告的，同时在接收过程中也不断的通告可以发送的窗口大小，来进行适应

2. Window Already Sent: 已经发送的数据，但是并没有收到ACK。

接收端数据类型：

1.  Received and ACK Not Send to Process：这部分数据属于接收数据但是还没有被上层的应用程序接收，是被缓存在窗口内。

2.  Received  Not ACK: 已经接收，但是还没有回复ACK，是缓存在窗口内的。这些帧可能属于Delay ACK的范畴。

3.  Not Received：还没有被接收的数据。


滑动窗口的原理：

**并不是每一个报文段都会回复ACK的，可能会对两个报文段发送一个ACK，也可能会对多个报文段发送1个ACK，这称为累积ACK**。
比如说发送方有1/2/3 3个报文段，先发送了2,3 两个报文段，但是接收方期望收到1报文段，这个时候2,3报文段就只能放在缓存中等待报文1。如果报文1一直不来（重传），报文2/3也将被丢弃；如果报文1来了，那么会发送一个ACK对这3个报文进行一次确认。

举一个例子：

1. 假设32~45 这些数据，是上层Application发送给TCP的，TCP将其分成四个Segment

2. seg1 32~34 seg2 35~36 seg3 37~41 seg4 42~45  这四个片段，依次发送出去，此时假设接收端之接收到了seg1 seg2 seg4

3. 此时接收端的行为是回复一个ACK包说明已经接收到了32~36的数据，并将seg4进行缓存（保证顺序，产生一个保存seg3 的空位）

4. 发送端收到ACK之后，就会将32~36的数据包从发送并没有确认 切换到 发送已经确认，这个时候窗口向右滑动

5. 若接收端通告的Window Size仍然不变，此时窗口右移，产生一些新的空位，这些是接收端允许发送的范畴

6. 对于丢失的seg3，如果超过一定时间，TCP就会重新传送（重传机制），重传成功会seg3 seg4一块被确认；若不成功，seg4也将被丢弃

就是不断重复着上述的过程，随着窗口不断滑动，将真个数据流发送到接收端，实际上接收端的Window Size通告也是会变化的，接收端根据这个值来确定何时及发送多少数据，从对数据流进行流控。原理图如下图所示：

![](http://img.blog.csdn.net/20160906084353705)

**滑动窗口的动态调整（流量控制）：根据接收端的接收情况，动态去调整Window Size，然后来控制发送端的数据流量**

举一个例子：

a. 包175，发送ACK携带WIN = 384，告知客户端，现在只能接收384个字节

b. 包176，客户端果真只发送了384个字节，Wireshark也比较智能，也宣告TCP Window Full

c. 包177，服务器回复一个ACK，并通告窗口为0，说明接收方已经收到所有数据，并保存到缓冲区；但是这个时候应用程序并没有接收这些数据，导致缓冲区没有更多的空间，故通告窗口为0, 这也就是所谓的零窗口。零窗口期间，发送方停止发送数据

d. 客户端察觉到窗口为0，则不再发送数据给接收方

e. 包178，接收方发送一个窗口通告，告知发送方已经有接收数据的能力，可以发送数据包

f. 包179，收到窗口通告之后，就发送缓冲区内的数据.

![](http://img.blog.csdn.net/20160907084827734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

