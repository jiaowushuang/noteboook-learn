**数字模块**

**引子**

到目前为止，布尔表达式、电路原理图和硬件描述语言都可以设计组合逻辑和时序逻辑电路。正如学习C语言需要了解一下常用到的库函数一样，学习数字电路一些必要的模块也是如此。

- 算术电路
- 计数器
- 移位寄存器
- 存储器阵列
- 逻辑阵列

牢记层次化、模块化、规整化三大原则。

- 复杂模块是可以以层次化的方法由更简单的模块（如逻辑门电路、复用器、译码器等）组成
- 确保每个模块都有明确定义的接口，并可以视为黑盒
- 确保每个模块的构成规则都易于扩展到更大的规模

最终上述这些模块将会构成微处理器（某种连接）。
侧重于速度和硬件复杂度之间的折中。

**算术电路**

1、加法

半加器（1位）：半加器可以用一个异或门和与门实现；在多位加法器中，C_out会被相加或进位到下一高位；然而半加器缺少一个输入C_in来接受前一个半加器的输出C_out。**逻辑表达式：S = A^B ; C_out = A&B**

全加器（1位）：上述的改良。**逻辑表达式：S = A^B^C_in ; C_out = A&B + A&C_in + B&C_in = A&B + (A+B)&C_in{先行进位}**

进位传播加法器（N位）：N位加法器是将两个N位输入（A/B）和一位进位C_in相加，并产生一个N位结果S和一个输出进位C_out。由于进位会传播到下一位，故而可称为进位传播。除了A/B/S是总线外（非一位），它与全加器相当类似。
- 行波进位加法器
- 先行进位加法器
- 前缀加法器

1. 行波进位：将N个全加器串联起来，即当前级的C_out就是下一级的C_in。（模块化、规整化）。**缺陷：当N比较大时，运算速度会降低；延迟：t_ripple = Nt_fa，即会随着位数的增加而增加；原因：进位信号必须通过每一级进行传播**。
2. 先行进位：把加法器分解成若干块（行波进位），同时增加电路（先行控制逻辑），当每块 一有进位时就快速确定此块的输出进位。也就是说，这是针对于进位输出所做的改良(所有的块在同时计算产生信号和传播信号)。它并不需要等待进位行波“抵达终点”，而是可以先行“退场”。（模块化、规整化）**机制：使用产生（G）和传播（P）信号来描述“一块”是如何确定进位输出的。所谓产生（G）进位是指在不考虑进位输入的情况下，且加法器必然会产生一个输出进位的情况（即A/B均为1）G=A&B；所谓传播（P）进位是指在考虑进位输入的情况下，加法器所产生进位输出的现象（即A或B为1，进位输入C_in）P=A+B；利用上述定义，可以为加法器重写进位逻辑，即加法器可以产生一个进位G或是传播一个进位输入P&C_in；逻辑函数如上**。产生和传播的定义可以扩展到多位块。例如：32位的加法器可以由8个4位块组成，而每个块的逻辑函数为C_out_3=G_3:0+P_3:0&C_in.（进而：G_3:0=G_3+P_3(G_2+P_2(G_1+P_1G_0);P_3:0=P_3P_2P_1P_0）。**缺陷：延迟依然随N线性增长；延迟：分解为k块的N位加法器：t_cla=t_pg（生成P、G的逻辑） + t_pg_block（寻找P、G信号） + (N/k -1)t_and_or（最后的与或逻辑） + kt_fa；优势：N>16时，先行进位优于行波进位**。
3. 前缀进位：略

记住：更 快 的加法器需要更多的硬件，因而 成本和功耗 也很高。设计选择合适的加法器需要充分考虑这些折中。
硬件描述语言提供 + 来表示CPA**{c_out,s}=a+b+c_in**。而综合工具选择更便宜的设计来满足速度的要求。

2、减法

加法器可以使用二进制补码来表示正数和负数的加法（即减法）。其中：改变二进制补码的符号的方法是反转所有位，然后加1.（A-B对加法器的改进：对B端口加一个反转器；然后将C_in置位）
**y=a-b**

3、比较器：比较两个二进制数是否相等，或是谁大谁小。
- 相等比较器：产生一个输出，说明是否相等。**同或门、与门：比较二者的每一位是否相等**
- 量值比较器：产生一个或多个输出，说明二者之间的关系。**计算A-B减法器的值，然后检查结果的符号位（最高有效位）符号位为负，则表明是负数**。
硬件描述语言的运算符号：“== ！= < <= > >=”

4、算术逻辑单元ALU：将多种算术和逻辑运算组合在一起，以及产生一些额外的输出（称作标志）。它表示ALU输出的信息（例如：溢出标志、零标志等）。
5、移位器和循环移位器：用于移动位以及完成2的幂乘/除操作。
- 逻辑移位器：右移以0填充空位
- 算术移位器：右移以最高有效位填充空位
- 循环移位器：头尾相接
**机制：N位移位器可以用N个N:1复用器构成，根据logN位的选择线的值，输入可以从位_0移动到位_N-1。**循环移位器留作练习。
硬件描述语言的运算符号："<<(左移) >>（逻辑右移） >>>（算术右移）"

6、乘法

被乘数、乘数、部分积、结果。**本质，部分积：乘数的某一位*被乘数的所有位；结果：错位这些部分积，并使其相加即可**
记住：NxN乘法器会产生2N位的结果。并且，1位二进制乘法相当于与运算，故而与门用于产生部分积。**对于N位运算数，每级有N个部分积（N级）、1位加法器（N-1级）。**
**不同的乘法器设计有不同的速度和成本；综合根据时序约束选择最合适的设计。**
硬件描述语言的运算符号：y=a*b

7、除法

对于N位无符号数，二进制除法是：A/B=Q+R/B
    r'=0 //中间余数
    for i=N-1 to 0
        r={r'<<1,A_i} //A被除数
        D=r-B		  //B除数
		
		if D<0 then Q_i=0,r'=r  //r余数
		else        Q_i=1,r'=D  //Q商
	r=r'

被除数、除数、中间余数、余数、商。**本质，先比较被除数和除数的大小，若大则令被除数-除数；中间余数是差值，商置位。同理将中间余数与除数比较，若大则....。直至小，得出最终结果。**
记住：2N除以N会产生N位的结果。**1位除法：减法器和量值比较器（减法器）：（复用器）；n位除法：上述单元的阵列。**
因为在确定 符号N和复用器 来选择R或D前，进位必须逐次通过一行的所有N级，所以N位除法器阵列的延迟按N^2比例增长。**除法是缓慢且耗费硬件资源的运算，应尽量少用。**

**数制**

计算机可以对整数和小数进行运算。
之前针对有符号和无符号整数做出了阐述，接下来会介绍定点和浮点数（有理数）。
    - 定点数：与十进制数类似，某些位表示整数部分，某些位表示小数部分
    - 浮点数：与科学计数法类似，包含尾数和阶码

**定点数**

定点表示法暗含一个位于整数和小数位之间的小数点；有符号定点数可以用二进制补码或是带符号的原码表示。（原码转补码，需要将原码整体取反，然后加1；同时无符号数变为有符号数；等价于十进制外加负号）。

**与所有二进制表示的数一样，定点数仅是位的集合；除非给出具体的解释，否则无法知道是否存在暗含的小数点。**

**浮点数**

浮点数包含 符号、尾数、基数和阶码。二进制浮点数的基数为2；尾数为二进制（小数点紧邻最高有效位之后）；在32位浮点数中用1位表示符号（正数为0、负数为1），8位表示阶码，23位表示尾数（MSR->LSR顺序）。
效率改良（IEEE 754浮点数标准）：
1. 尾数的第一位（小数点的左一位）总是为1，因此不需要存储。其称为隐含前导1，没有包含在23位的尾数中。**23位尾数仅存储小数部分的位。**
2. 阶码需要表示正数阶码和负数阶码。**引入偏置阶码：原始阶码加上一个常数偏置。**32位浮点数使用的偏置为127。
 
- 特殊情况：0、无穷和非法结果（IEEE 754浮点数标准使用特殊方式来表示。**隐含前导1导致表示数字0存在问题。**可以采用全0和全1填充阶码来解决特殊情况）
- 单精度和双精度：32位浮点数（单精度）、64位浮点数（双精度）。在64位浮点数中用1位表示符号（正数为0、负数为1），11位表示阶码，52位表示尾数（MSR->LSR顺序）。

**正常单精度浮点数的取值范围（十进制）{精度7位有效数字；阶码38}；正常双精度浮点数的取值范围（十进制）{精度15位有效数字；阶码308}**
**拿单精度来说，23位尾数表示2^24=10^7（精度7位）；8位阶码（实质上是7位，1位符号位）表示2^7，即2^128=10^38（阶码38）**

**舍入**：在有效精度外的算术结果必须四舍五入到最近的值。

舍入模式：
- 向上舍；向下舍；向0舍
- 向最近端舍（默认）：在向最近端舍入的模式中，若两端的距离相等，则选择小数部分最低有效位为0的那个。
1. 当一个数的数值部分太大而不能表示时，会产生上溢；在向最近端舍入的模式中，正负无穷；
2. 当一个数的数值部分太小而不能表示时，会产生下溢；在向最近端舍入的模式中，0；

**浮点数加法**

同符号浮点数的加法步骤如下：
1. 提取阶码和小数位
2. 加上前导1，形成尾数
3. 比较阶码；计算差值（作为移位数）
4. 如果差值为正，右移加数；如果差值为负，左移被加数（对较小的尾数右移）
5. 尾数相加，阶码统一为较大的那个
6. 规范化尾数，必要时调整阶码（小数点左移一位，阶码加1）
7. 舍入结果
8. 将阶码和小数位组合成浮点数

**时序电路模块**

- 计数器
- 移位寄存器

**计数器**

机制：可以由加法器（半加器即可）、带复位和时钟端的寄存器构成。在每个时钟周期，计数器对存储在寄存器中的值加1。（N位）。其他类型的计数器（如UP/DOWN计数器）自行查询。
    if(reset) q<=0;
	else      q<=q+1;
**移位寄存器：串/并转换**

1. 包括：时钟、串行输入、串行输出以及N位并行输出（可能含有复位信号）。输入以串行的方式提供，在N个周期后，前面的N位输入可以并行访问。
机制：使用N个触发器串联而成。
2. 增加并行输入和控制信号（加载信号）后，移位寄存器可以修改为“既是串转并，又是并转串”。
机制：增加N个复用器。
    	if(reset)      q<=0;
		else if (load) q<=d;
		else           q<={q[N-2:0],sin};
	assign sout=q[N-1];

扫描链：利用这种技术，移位寄存器经常用于测试时序电路。

**存储器阵列**

上述介绍了操作数据的组合、时序电路。当然，数字系统还需要存储器来保存电路的数据。
- 以触发器组成的寄存器是存储少量数据的存储器
- 以存储器阵列可以保存大量数据

三种类型的存储器阵列：存储数据的方式不同
1. 动态随机访问存储器（DRAM）
2. 静态随机访问存储器（SRAM)
3. 只读存储器（ROM）

- 面积和延迟的折中
- 存储器阵列的逻辑功能

**概述**

由一个二维的存储器位单元阵列构成。**存储器可以读取或者写入数据到阵列的某一行。**
- 行由N位地址标识（每行的数据称为字）
- 读写M位数据
- N位地址和M位数据的阵列：2^N行和M列**（阵列包含2^N个M位字）**
- **阵列的深度即行数（地址）；宽度即列数（字大小）。阵列的容量为深度*宽度（单位:KB）。**

位单元：存储1位的数据；每一个位单元都与一个字线和一个位线相连。对于每一个有效的地址（位），存储器会将字线设置为高电平，并激活该行的位单元（使能位单元）。
**位单元的电路因存储器类型而不同。**

存储器的结构
1. 读：位线初始化为浮空；字线设置为高电平；（以位单元存储的值来驱动位线）
2. 写：位线强制驱动“想要的值”；字线设置为高电平；（使位线的值存储到位单元）

存储器端口
所有的存储器都有一个或多个端口；而每个端口都提供对一个存储器地址的读/写访问。**多端口存储器可以同时访问多个地址（多对addr/data）。**

存储器类型
**存储器可以根据如何在位单元上存储位来分类。**
- 随机访问存储器（RAM）：易失
- 只读存储器（ROM）：非易失

**随机访问：访问任何数据字的延迟都相同；与之相对的是，顺序访问：获得临近数据会比获得较远数据更快**
**澄清：ROM也是随机访问的，同时既可以读、也可以写（时代在变，命名没变）。**

- RAM：

	DRAM（电容充放电来存储数据：读会破坏存储在电容的位值，所以每次读后需要重写数据；电容的电压会随时间泄露，因而内容需要刷新{读，然后重写}）
	SRAM（使用交叉耦合的反相器来存储数据：不需要刷新{恢复位值}）

	面积和延迟：比较触发器、SRAM、DRAM
	1、晶体管数越多的器件，芯片面积、功耗和成本也更高；但相应的访问速度最快（对于触发器，虽然可以通过输出直接访问存储的数据，但是至少需要20个晶体管；同理对于SRAM：6/DRAM：1）
    2、延迟和吞吐量：DRAM比SRAM延迟更长，因为位线并不是由晶体管驱动的，而且必须等待充电，从电容将值移动到位线的速度很慢；DRAM比SRAM吞吐量更低，因为需要周期性的刷新（时钟利用率低）。当然，延迟和吞吐量也与存储器的大小有关（一般情况下，大容量的存储器比小容量的存储器更慢）。
	3、新DRAM技术：同步DRAM（SDRAM）{使用一个时钟使存储器访问流水线化}和双倍数据速率SDRAM（DDR）{使用时钟的上升沿和下降沿来存储数据，即双倍的吞吐量}。

	寄存器文件：数字系统常使用一组寄存器来存储临时变量。它通常由多端口SRAM阵列组成。这与触发器阵列所组成的寄存器不同。

- ROM：根据擦写方式的不同可以有多钟类型

	{只读ROM}：以晶体管是否存在来存储一位：读位单元，位线首先拉至高电平；随后打开字线。（若存在：位单元存储0，它使位线拉至低电平；若不存在：位单元存储1，位线将保持高电平）。
	因为ROM位单元是组合电路，在电源关闭的情况下，没有可以“忘记”的状态。
	{可编程PROM}：在每一个位单元都放置一个晶体管，然后提供方法来决定是否接地。
		1、熔丝烧断PROM位单元：使用者应用高电压有选择的熔断熔丝来对ROM编程。若熔丝存在，则表示接地：0；若熔丝熔断，则表示断开：1。（一次可编程）。
		2、可擦除PROM（EPROM）：将nMOS晶体管和熔丝换为浮动栅晶体管（合适的高电平：编程；紫外线：擦除）
		3、电子可擦除PROM（EEPROM）和闪存采用相似的原理（擦除方式是使用电路）。

使用存储器阵列的逻辑：实现组合逻辑功能（译码器）

1. 一个2^N字 * M位的存储器可以实现任何 N输入和 M输出的组合功能。
2. **用于执行逻辑的存储器阵列称为查找表（LUT）。**
3. 使用存储器实现逻辑时，用户可以根据给出的输入组合（也就是地址）来查找输出值（也就是位单元存储的值）；
4. 每个地址对应**真值表**的输入值（一行），每个位单元的值对应**真值表**的输出值。
硬件描述语言：
    (1)2^N字 * M位 RAM：同步写使能

	logic [M-1:0] mem[2**N-1：0]；
	always_ff@(posedge clk)
		if(we) mem[adr] <= din;
	assign dout = mem[adr];
	
	(2)4字 * 3位 ROM：ROM的内容会在case语句中说明（一般来说，小ROM会被综合为逻辑门电路{译码器}，而不是阵列）

	always_comb
	case(adr)
		2'b00:dout <= 3'b011;
		2'b01:dout <= 3'b110;
		2'b02:dout <= 3'b100;
		2'b03:dout <= 3'b010;
	endcase

**逻辑阵列**

与存储器一样，逻辑门也可以组织成阵列。
**若门与门之间的连接是可以编程的，那么逻辑阵列便可以执行任何功能而不需要使用者特定的连线。**
软件编程工具允许用户将 逻辑设计（硬件描述性语言或是原理图） 映射到 逻辑阵列中。大部分的逻辑阵列是可重构的，这使得不需要替换硬件便可以修改设计。

- 可编程逻辑阵列（	PLA）：组合逻辑
- 现场可编程门阵列（FPGA）：组合逻辑和时序逻辑
-----------------------------------------------------------------------------------------------------------------------
**可编程逻辑阵列**

以与或的形式实现两级组合逻辑。
**机制：PLA由一个AND阵列、后跟一个OR阵列组成。其中，输入（真值形式和取反形式）驱动AND阵列；其产生的蕴含项依次做OR运算（阵列）来形成输出。**
一个M*N*P的PLA含有M位输入，N位蕴含项和P位输出。ROM可以看做是PLA的一种特殊情况。2^N字 * M位 ROM就是一个 N*2^N*M 位的PLA。
**若逻辑函数不需要依赖所有的2^N个最小项，则PLA是小于ROM的。**
简单可编程逻辑器件（SPLD）增强PLA的功能，然而无论是PLA还是SPLD大多被FPGA所取代。

------------------------------------------------------------------------------------------------------------------------
**现场可编程逻辑门阵列**

1. 实现多级逻辑（PLA只能实现两级逻辑）
2. 组合和时序逻辑
3. 其他功能：内置乘法器、高速IO、数据转换器（模数）、大型RAM阵列以及处理器等

**机制：FPGA是可配置逻辑元件阵列（LE），也称为可配置逻辑单元阵列（CLB）。**每个LE可以配置实现组合逻辑和时序逻辑。

通用FPGA模块：
1. LE阵列被 外部接口的输入/输出元件（IOE）包围。
2. IOE将LE的输入/输出与芯片封装的管脚相连。
3. 通过可编程布线可以将LE、其他LE和IOE连接在一起。

Altera公司Cyclone IV FPGA 的LE结构：
1. 关键部分是一个 4输入查找表（LUT）和一个 1位可编程寄存器。
2. 可配置复用器：选择特定的信号通过LE。
3. 通过确定查找表的内容和复用器的选择信号 来配置FPGA。

- 该LE 为查找表加载合适的值后，可以配置LUT来实现最多4变量的任意函数。
- 配置FPGA时还需要包括 选择信号，该信号决定 数据如何通过复用器 从LE路由到临近的LE和IOE。
- 额外的硬件包括：支持使用 带进位链的加法器；用于路由的多路复用器；寄存器的使能端和复位键。
- Altera公司将 16个LE组合在一起构成一个逻辑阵列单元（LAB），并提供LAB内的LE之间的本地连接。

**Cyclone IV LE 可以实现最多4变量的组合函数以及寄存器函数。其他公司可能结构不同，但是设计思路一致。**

配置FPGA：
1. 设计者创建设计的原理图和硬件描述程序
2. 设计综合到FPGA（由综合工具决定 LUT、复用器和布线通道是如何配置 来实现特定功能）
3. 配置信息下载到FPGA
4. Cyclone IV在SRAM里存储配置信息；有些制造商是直接包含EEPROM或是使用一次可编程熔丝来配置FPGA

