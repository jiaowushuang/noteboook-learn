**数字模块**

**引子**

到目前为止，布尔表达式、电路原理图和硬件描述语言都可以设计组合逻辑和时序逻辑电路。正如学习C语言需要了解一下常用到的库函数一样，学习数字电路一些必要的模块也是如此。

- 算术电路
- 计数器
- 移位寄存器
- 存储器阵列
- 逻辑阵列

牢记层次化、模块化、规整化三大原则。

- 复杂模块是可以以层次化的方法由更简单的模块（如逻辑门电路、复用器、译码器等）组成
- 确保每个模块都有明确定义的接口，并可以视为黑盒
- 确保每个模块的构成规则都易于扩展到更大的规模

最终上述这些模块将会构成微处理器（某种连接）。
侧重于速度和硬件复杂度之间的折中。

**算术电路**

1、加法

半加器（1位）：半加器可以用一个异或门和与门实现；在多位加法器中，C_out会被相加或进位到下一高位；然而半加器缺少一个输入C_in来接受前一个半加器的输出C_out。**逻辑表达式：S = A^B ; C_out = A&B**

全加器（1位）：上述的改良。**逻辑表达式：S = A^B^C_in ; C_out = A&B + A&C_in + B&C_in = A&B + (A+B)&C_in{先行进位}**

进位传播加法器（N位）：N位加法器是将两个N位输入（A/B）和一位进位C_in相加，并产生一个N位结果S和一个输出进位C_out。由于进位会传播到下一位，故而可称为进位传播。除了A/B/S是总线外（非一位），它与全加器相当类似。
- 行波进位加法器
- 先行进位加法器
- 前缀加法器

1. 行波进位：将N个全加器串联起来，即当前级的C_out就是下一级的C_in。（模块化、规整化）。**缺陷：当N比较大时，运算速度会降低；延迟：t_ripple = Nt_fa，即会随着位数的增加而增加；原因：进位信号必须通过每一级进行传播**。
2. 先行进位：把加法器分解成若干块（行波进位），同时增加电路（先行控制逻辑），当每块 一有进位时就快速确定此块的输出进位。也就是说，这是针对于进位输出所做的改良(所有的块在同时计算产生信号和传播信号)。它并不需要等待进位行波“抵达终点”，而是可以先行“退场”。（模块化、规整化）**机制：使用产生（G）和传播（P）信号来描述“一块”是如何确定进位输出的。所谓产生（G）进位是指在不考虑进位输入的情况下，且加法器必然会产生一个输出进位的情况（即A/B均为1）G=A&B；所谓传播（P）进位是指在考虑进位输入的情况下，加法器所产生进位输出的现象（即A或B为1，进位输入C_in）P=A+B；利用上述定义，可以为加法器重写进位逻辑，即加法器可以产生一个进位G或是传播一个进位输入P&C_in；逻辑函数如上**。产生和传播的定义可以扩展到多位块。例如：32位的加法器可以由8个4位块组成，而每个块的逻辑函数为C_out_3=G_3:0+P_3:0&C_in.（进而：G_3:0=G_3+P_3(G_2+P_2(G_1+P_1G_0);P_3:0=P_3P_2P_1P_0）。**缺陷：延迟依然随N线性增长；延迟：分解为k块的N位加法器：t_cla=t_pg（生成P、G的逻辑） + t_pg_block（寻找P、G信号） + (N/k -1)t_and_or（最后的与或逻辑） + kt_fa；优势：N>16时，先行进位优于行波进位**。
3. 前缀进位：略

记住：更 快 的加法器需要更多的硬件，因而 成本和功耗 也很高。设计选择合适的加法器需要充分考虑这些折中。
硬件描述语言提供 + 来表示CPA**{c_out,s}=a+b+c_in**。而综合工具选择更便宜的设计来满足速度的要求。

2、减法

加法器可以使用二进制补码来表示正数和负数的加法（即减法）。其中：改变二进制补码的符号的方法是反转所有位，然后加1.（A-B对加法器的改进：对B端口加一个反转器；然后将C_in置位）
**y=a-b**

3、比较器：比较两个二进制数是否相等，或是谁大谁小。
- 相等比较器：产生一个输出，说明是否相等。**同或门、与门：比较二者的每一位是否相等**
- 量值比较器：产生一个或多个输出，说明二者之间的关系。**计算A-B减法器的值，然后检查结果的符号位（最高有效位）符号位为负，则表明是负数**。
硬件描述语言的运算符号：“== ！= < <= > >=”

4、算术逻辑单元ALU：将多种算术和逻辑运算组合在一起，以及产生一些额外的输出（称作标志）。它表示ALU输出的信息（例如：溢出标志、零标志等）。
5、移位器和循环移位器：用于移动位以及完成2的幂乘/除操作。
- 逻辑移位器：右移以0填充空位
- 算术移位器：右移以最高有效位填充空位
- 循环移位器：头尾相接
**机制：N位移位器可以用N个N:1复用器构成，根据logN位的选择线的值，输入可以从位_0移动到位_N-1。**循环移位器留作练习。
硬件描述语言的运算符号："<<(左移) >>（逻辑右移） >>>（算术右移）"

6、乘法

被乘数、乘数、部分积、结果。**本质，部分积：乘数的某一位*被乘数的所有位；结果：错位这些部分积，并使其相加即可**
记住：NxN乘法器会产生2N位的结果。并且，1位二进制乘法相当于与运算，故而与门用于产生部分积。**对于N位运算数，每级有N个部分积（N级）、1位加法器（N-1级）。**
**不同的乘法器设计有不同的速度和成本；综合根据时序约束选择最合适的设计。**
硬件描述语言的运算符号：y=a*b

7、除法

对于N位无符号数，二进制除法是：A/B=Q+R/B
    r'=0 //中间余数
    for i=N-1 to 0
        r={r'<<1,A_i} //A被除数
        D=r-B		  //B除数
		
		if D<0 then Q_i=0,r'=r  //r余数
		else        Q_i=1,r'=D  //Q商
	r=r'

被除数、除数、中间余数、余数、商。**本质，先比较被除数和除数的大小，若大则令被除数-除数；中间余数是差值，商置位。同理将中间余数与除数比较，若大则....。直至小，得出最终结果。**
记住：2N除以N会产生N位的结果。**1位除法：减法器和量值比较器（减法器）：（复用器）；n位除法：上述单元的阵列。**
因为在确定 符号N和复用器 来选择R或D前，进位必须逐次通过一行的所有N级，所以N位除法器阵列的延迟按N^2比例增长。**除法是缓慢且耗费硬件资源的运算，应尽量少用。**


