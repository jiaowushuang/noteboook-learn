<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, MWS); Windows/10.0.15063 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="376"/>

<div>
<span><div><span style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none; background-color: rgb(255, 255, 255);">【宿主机】进行软件研究时，其环境会用到一个服务器层（在发布之前的一个特定功能的平台）；该环境的目的是加快在客户端-服务器的开发、测试、发布进程。</span><br style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"/><br style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"/><span style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none; background-color: rgb(255, 255, 255);">1.开发环境： </span><br style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"/><span style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none; background-color: rgb(255, 255, 255);">这是一个针对 个人开发者 或是 小型团队 的集成开发环境；该环境的目的是为了让开发者在【本地宿主机】工作，并将他们与团队的其他成员“隔离”开——允许开发者对软件进行不同程度的修改，而不用担心这么做可能会改变其他成员的工作成果。</span><br style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"/><br style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"/><span style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none; background-color: rgb(255, 255, 255);">2.脚手架环境：</span><br style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"/><span style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none; background-color: rgb(255, 255, 255);">在软件进入生产环境之前，于该环境中进行装配、测试以及回顾通常，脚手架环境尽可能地尝试去模仿生产环境（硬件以及软件）。正常情况，在生产环境发布一个更新的软件版本之前，其更新必须在脚手架环境进行测试。故该环境也常被用来作为一个证明/训练环境。</span><br style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"/><br style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"/><span style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none; background-color: rgb(255, 255, 255);">3.生产环境：</span><br style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"/><span style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none; background-color: rgb(255, 255, 255);">这是软件最终走向世界，活跃姿态的“live”环境；</span><br style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"/><br style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"/></div><div><span style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: 14px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none; background-color: rgb(255, 255, 255);">【注：从一个环境（3）转换到另一个环境（3）需要使用版本控制代码。】</span></div></span>
</div>
<hr>
<a name="422"/>

<div><span><div><table bgcolor="#D4DDE5" border="0" style="width:967px;" width="100%"><tbody><tr><td style="width:99.58634953464323%;"><h1>第三章：程序的机器级表示</h1><b>作者：</b> iaowushuangi@yahoo.com</td></tr></tbody></table></div><div><div><br/></div><ul><li><b>机器代码：字节序列。计算机执行机器代码，并以此编码低级的操作（包括处理数据，管理内存，读写存储设备上的数据，以及网络通信）。</b></li><li><b>汇编代码：机器代码的文本表示，给出程序中的每一条指令。</b></li></ul><div><br/></div><div><img src="深入系列_files/绋嬪簭鐨勬満鍣ㄧ骇琛ㄧず.svg" type="image/svg+xml" style="height: auto;"/></div><div><hr/></div><ul><li><b>高级语言编程（高抽象级别）：用高级语言编写的程序可以在很多不同的机器上编译和执行。机器屏蔽了程序的细节，即机器级的实现。</b></li><li><b>汇编语言编程（低抽象级别）：汇编代码是与特定机器密切相关的 。程序员必须指定程序用来计算的低级指令。编译器可以充当黑盒，将繁琐的细节隐藏；优化后的编译器效率媲美。</b></li></ul><div><br/></div><div><hr/></div><div><b><span style="font-size: 16px;">为什么学习机器代码呢？</span></b></div><div><br/></div><div>程序员学习汇编语言的需求随着时间的推移发生了变化。开始要求程序员能直接使用汇编语言编写程序；但是。</div><div>现在，能够阅读和理解编译器产生的汇编代码则是一项重要的技能。</div><div><br/></div><ul><li>以适当的命令行选项调用编译器，编译器便会输出一个“以汇编代码形式表示的输出文件”。</li><li>通过阅读汇编代码，以理解编译器的优化能力，并分析代码中隐含的低效率。（即：试图最大化一段关键代码性能的程序员，通常会尝试源代码的各种形式；每次编译并检查产生的汇编代码，从而了解程序将运行的效率如何）</li><li>高级语言提供的抽象层会隐藏我们想要了解的程序的运行时行为。但这些信息在机器代码级是可见的。</li><li>了解漏洞是如何出现的，以及如何防御它们，需要具备程序机器级表示的知识。</li></ul><div><br/></div><div><b><span style="font-size: 16px;">如何阅读编译器产生的汇编代码呢（与手工编写汇编代码所需的技能不同）？</span></b></div><div><br/></div><ul><li>必须了解“典型编译器”在将C程序结构变换成机器代码时所做出的转换。
<ul><li>与C代码表示的计算操作不同，优化编译器能够重新排列执行顺序，消除不必要的计算，用快速操作替换慢速操作，甚至将递归计算变换成迭代计算。彻底毁容。所以在阅读汇编代码时尽量不要优化。</li></ul></li><li>逆向工程：通过研究系统（汇编代码）和逆向工作，来试图了解系统（汇编代码）的创建过程。但是，源代码与汇编代码的对应关系（遵循比较规则的模式）通常不容易理解。</li></ul><div><br/></div><div><b><span style="font-size: 16px;">机器语言的种类有哪些呢？</span></b></div><div><br/></div><div>我们的表述基于x86-64，是一种应用范围极广的处理器的机器语言。</div><div>它有一个很长的演化史，但演化的结果是得到一个相当奇特的设计。有些特性只有从历史的观点来看才有意义。</div><div>虽然具备向后兼容，但是现代编译器和操作系统早已不在使用某些陈旧的特性。故而，我们将 <b>重点关注GCC和linux（ATT）使用的这些特性 </b>，以避免x86-64的复杂性和隐秘特性（取一个适当的子集）。而当我们想要将所学的汇编知识“可移植化”时，只需将GCC（+ATT选项）可移植化即可；这时便要POSIX出场了。</div><div><br/></div><div>IA32：x86-64的32位前身。当今大多数x86微处理器以及这些机器上安装的操作系统，都是为x86-64设计的。不过，它们也可以向后兼容执行IA32程序。当然，一些限制也使得IA32比x86-64更有广泛基础。</div><div><br/></div><div>我们的表述集中于以现代操作系统为目标，编译C语言或其他语言时，生成的机器级程序类型。故而，x86-64的一些遗留特性（支持早期微处理器的编程风格：斤斤计较的有限地址空间）我们不去考虑。</div><div><br/></div><div><b><span style="font-size: 16px;">我们的学习流程是如何的呢？</span></b></div><div><br/></div><ul><li>浏览C语言，汇编代码以及机器代码之间的关系。</li><li>介绍x86-64的技术细节。</li></ul><div><br/></div><div>从数据的表示和处理以及控制的实现开始（机器级编程：汇编编程）。</div><div><br/></div><div><img src="深入系列_files\en_todo.png"/>实现C语言中的控制结构，如if,while,swith。</div><div><img src="深入系列_files\en_todo [1].png"/>过程的实现，包括程序如何维护一个运行栈来支持过程间数据和控制的传递，以及局部变量的存储。</div><div><img src="深入系列_files\en_todo [2].png"/>考虑如何在机器级实现像数组，结构，联合这样的数据结构。</div><div><img src="深入系列_files\en_todo [3].png"/>包含浮点数据和操作的代码的机器级表示。</div><div>   </div><ul><li>讨论内存访问越界的问题，以及系统容易遭受缓冲区溢出攻击的问题。</li><li>使用GDB调试器检查机器级程序运行时行为的技巧。</li></ul><div><br/></div><div><br/></div><div><span style="font-size: 16px;"><b>历史观点</b></span></div><div><br/></div><div>Intel处理器系列俗称x86，经历了一个长期的，不断进化的发展过程。</div><div>以下列举了一些Intel处理器的模型以及它们的一些关键特性（特别是影响机器级编程：汇编指令集及编程的特性）；可以说，实现这些处理器所需的晶体管数量影响着该演变过程的复杂性。</div><div><br/></div><div>X86：用它指代整个系列。</div><div><br/></div><ul><li>8086（29K个晶体管）：单芯片，<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">16位</span>微处理器。8088是8086的一个变种，增加了一个8位的外部总线，并以此开发出<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">MS-DOS</span>操作系统。从体系结构上来说，这些机器只有655360字节的地址空间，而地址只有20位长（可寻址1048576字节），而操作系统保留393216字节自用。<u>Intel于不久开发出8087浮点协处理器（45K个晶体管 ），它与8086/8088一同运行，执行浮点指令。8087建立了x86系列的浮点模型，称为<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">x87</span>。</u></li><li>80286（134K个晶体管 ）：<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">增加了更多的寻址模式</span>（现已废弃），并作为<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">MS-Windows</span>的最初的使用平台。</li></ul><div><br/></div><div>最初8086提供的“内存模型和它在80286上的扩展”，到i386的时候就已过时。</div><div><br/></div><div>IA32：Intel32位体系结构。</div><ul><li>i386（275K个晶体管 ）：将体系结构扩展到<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">32位</span>。增加了<b><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">平坦寻址模式（linux和现今的windows操作系统都是使用该模式）</span></b>。</li><li>i486（1.2M个晶体管 ）：改善了性能，并将浮点单元集成到处理器芯片上，但是指令集并没有明显变化。</li><li>Pentium（3.1M个晶体管 ）：改善了性能，并对指令集做出了小幅改动。</li><li>PentiumPro（5.5M个晶体管 ）：全新的处理器设计，在内部被称为<b><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">P6微体系结构</span></b>。<b><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">指令集增加了一类“条件传送指令”</span></b>。</li><li>Pentium/MMX（4.5个晶体管 ）：<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">增加了一类“新的处理整数向量的指令”</span>。每个数据大小可以是1，2，4字节。每个向量总长8个字节。</li><li>PentiumII（7M个晶体管 ）：P6微体系结构的延伸。</li><li>PentiumIII（8.2M个晶体管 ）：<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">引入SSE，“一类处理整数或浮点数向量的指令”</span>。每个数据大小可以是1，2，4字节。每个向量总长16个字节。芯片上包括了<b><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">二级高速缓存</span></b>。</li></ul><div><br/></div><div>原来的X87浮点指令到引入SSE2之后就已过时。</div><div><br/></div><ul><li>Pentium4（42M个晶体管 ）：<b><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">SSE扩展到SSE2，增加了“新的数据类型（包括双精度浮点数）及其对应的144条指令”</span></b>。根据此扩展，编译器可以使用SSE指令，而不是X87指令，来编译浮点代码。</li></ul><div><br/></div><div>X86-64：Intel64，即IA32的64位扩展。</div><ul><li>Pentium4E（125M个晶体管）：增加了<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">超线程</span>（使一个处理器同时运行两个程序）。增加了EM64T，是对IA32的<b><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">64位</span></b>扩展的实现，也称为X86-64。</li><li>Core2（291M个晶体管 ）：类似于P6的微体系结构。是<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">多核处理器</span>（即多处理器实现在一个芯片上），但不支持超线程。</li><li>Corei7,Nehalem（786M个晶体管 ）：<b><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">既支持超线程，又有多核</span></b>。最初是支持“每个核上执行两个程序，每个芯片最多有四个核”。</li><li>Corei7,Sandy Bridge（1.17G个晶体管 ）：引入了<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">AVX</span>，这是对SSE的扩展。支持把数据封装到32字节的向量。</li><li>Corei7,Haswell（1.4G个晶体管 ）：<b><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">将AVX扩展到AVX2，增加了更多的指令和指令格式</span></b>。</li></ul><div><br/></div><div>NOTE</div><ul><li>虽然这里讲述的是Intel处理器，但是对于与之兼容的其他处理器来说，这些表述也是成立的（能够运行完全相同的机器级代码）。</li><li>每个后继处理器的设计都是后向兼容的（较早版本上编译的代码可以在较新的处理器上运行）。为了保持这种进化传统，指令集中有很多非常奇怪的东西。但是对于由GCC编译，在linux平台上运行的程序来说，大多数人都不关心X86的复杂性。虽然在X86-64的程序中，我们可以看到历史发展的轨迹，但是X86中最晦涩难懂的特性已不再出现。</li></ul><div><u><br/></u></div><div><hr/></div><div><b><span style="font-size: 19px;">程序编码</span></b></div><div><span style="font-size: 16px;"><u><br/></u></span></div><div><b><span style="font-size: 16px;">机器级代码</span></b></div><div><br/></div><div>计算机系统使用多种不同形式的抽象，并利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要。</div><ul><li>由指令集体系结构或指令集架构（ISA）来 定义机器级程序的格式和行为：包括处理器状态，指令的格式，以及每条指令对状态的影响。</li><li>机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。</li></ul><div><br/></div><div><b>能够理解汇编代码以及它与原始C代码的联系，是理解计算机如何执行程序的关键一步。但是，</b>X86-64的机器代码与原始C代码差别很大。通常一些对C语言程序员隐藏的“处理器状态都是可见的于汇编 ”。</div><ul><li>程序计数器（通常称为PC，在X86-64中用 %rip 表示）：给出将要执行的下一条指令在内存中的地址。</li><li>整数寄存器文件：包含16个命名的位置，分别存储64位的值。
<ul><li>这些寄存器可以存储地址（对应于C语言的指针）。</li><li>也可以存储整数数据（对应于C语言的整型数据结构）。</li></ul></li></ul><div><br/></div><ul><li style="display:inline;list-style:none;"><ul><li>有的寄存器被用来记录某些重要的程序状态；<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">可以把程序视为一个状态机，这里代表的是状态机的<span style="font-size: 19px;">O</span>。</span></li><li>其他的寄存器则用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值（对应于C源代码的除预处理外的所有整型值）；<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">可以把程序视为一个状态机，这里代表的是状态机的<span style="font-size: 19px;">O</span>内编码的变量与值。</span></li></ul></li></ul><div><br/></div><ul><li>条件码寄存器：保存着最近执行的算术或逻辑指令的状态信息。它们用以实现控制或数据流中的条件变化（例如实现if,while...语句）；<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">可以把程序视为一个状态机，这里代表的是状态机的<span style="font-size: 19px;">-&gt;</span>。</span></li><li>一组向量寄存器：可以存放一个或多个整数或浮点值。</li></ul><div><br/></div><div><span style="font-size: 15px;"><b>所谓的联系（准确的说是区别）</b></span></div><div><b><span style="font-size: 15px;"><br/></span></b></div><ul><li>机器代码只是简单的将内存看作是一个很大的，按字节寻址的数组；并存储着不含特殊意义的数值。而聚合数据类型，在机器代码中用一组连续的字节来表示。机器代码无视C语言的内存分配模型。</li></ul><div><br/></div><ul><li><b>程序内存包括：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈以及用户分配的内存块（例如用malloc库函数分配的）。</b></li></ul><div><b><br/></b></div><ul><li>程序内存用虚拟地址来寻址，在任意给定的时刻，只有有限一部分虚拟地址被认为是合法的。</li><li>操作系统用来管理虚拟地址空间，将虚拟地址空间翻译成实际处理器内存中的物理地址。</li></ul><div><br/></div><ul><li><b>一条机器指令只执行一个非常基础的操作。而编译器必须产生这些指令的序列，从而实现（像算术表达式求值，循环或过程调用和返回这样的）程序结构。</b></li></ul><div><br/></div><div><hr/></div><div><b><span style="font-size: 16px;">访问信息</span></b></div><div><br/></div><ul><li>数据传送指令
<ul><li>MOV类
<ul><li>源操作数指定的值是一个立即数，存储在寄存器或内存中；而目的操作数指定一个位置，要么是寄存器，要么是内存地址。</li><li>限制：传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令：将源值加载到寄存器中，再将该寄存器的值写入目的位置。</li><li>源操作数与目的操作数大小一致，并且寄存器（立即数）大小要与后缀匹配。</li></ul></li><li>MOVZ类/MOVS类
<ul><li>较小源值，较大目的。</li><li>源操作数是寄存器和内存，目的操作数是寄存器。</li></ul></li><li>压入和弹出栈数据指令
<ul><li>栈在处理 过程调用 中起到至关重要的作用。</li><li>栈是一种数据结构，可以添加和删除值，不过要遵循“后入先出”的原则。</li><li>栈可以实现为一个数组，总是在数组的一端添加和删除元素。而这一端称为栈顶。当然，内存不也是可以抽象为一个数组吗？</li><li>栈和程序代码以及其他形式的程序数据都是放在同一内存中，所以程序可以用标准的内存寻址方式（任何的数据传送指令）访问栈内的数据。</li></ul></li></ul></li><li>算术和逻辑运算
<ul><li>加载有效地址：目的操作数必须是一个寄存器。
<ul><li>这条指令可以为后续的内存引用产生指针。</li><li>它还可以简洁的描述普通的算术操作。</li><li>而其他的灵活用法，根本就与有效地址计算无关。</li></ul></li><li>一元与二元操作
<ul><li>只有一个操作数，既是源又是目的。这个操作数可以是寄存器或内存位置。</li><li>第二个操作数既是源又是目的。第一个操作数可以使立即数，寄存器和内存位置；第二个操作数可以是寄存器或是内存位置。</li></ul></li><li>移位操作
<ul><li>移位量可以是一个立即数，或是放在单字节寄存器%cl中。</li><li>移位操作的目的操作数可以是一个寄存器，或是一个内存位置。</li></ul></li><li>特殊的算术操作</li></ul></li></ul><div><br/></div><div><hr/></div><div><span style="font-size: 16px;"><b>控制</b></span></div><div><br/></div></div><div><img src="深入系列_files/overview.png" type="image/png"/></div><div>条件码</div><div><br/></div><div>描述了最近的算术和逻辑操作的属性。</div><ul><li>CF：无符号操作的溢出（进位标志）</li><li>ZF：0（零标志）</li><li>SF：负数（符号标志）</li><li>OF：补码溢出（溢出标志）</li></ul><div><br/></div></span>
</div>
<hr>
<a name="596"/>

<div>
<span><div style="direction:ltr;border-width:100%"><div style="direction:ltr;margin-top:0in;margin-left:0in;width:8.5131in"><div style="direction:ltr;margin-top:0in;margin-left:.2909in;width:3.8854in"><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei Light&quot;;font-size:20.0pt">数字设计与计算机体系结构</p></div><div style="direction:ltr;margin-top:.0388in;margin-left:.2909in;width:1.9027in"><p style="margin:0in;font-size:10.0pt;color:#767676"><span style="font-family: Calibri">2016</span><span style="font-family:&quot;Microsoft YaHei&quot;">年</span><span style="font-family:Calibri">12</span><span style="font-family:&quot;Microsoft YaHei&quot;">月</span><span style="font-family:Calibri">12</span><span style="font-family:&quot;Microsoft YaHei&quot;">日</span></p><div style="margin: 0in; font-family: Calibri; font-size: 10pt;"><div><span style="color: rgb(118, 118, 118);">23:01</span><span style="font-family: 'Microsoft YaHei';"><span style="font-size: 11pt;"> </span></span></div></div></div><div style="direction:ltr;margin-top:.4895in;margin-left:0in;width:8.5131in"><ul style="margin-left:.2694in;direction:ltr;unicode-bidi:embed;margin-top: 0in;margin-bottom:0in"><li style="display:inline;list-style:none;"><ul style="margin-left:0in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-style:italic;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">二进制</span></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-style:italic;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">组合逻辑电路</span></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-style:italic;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">时序逻辑电路</span></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-style:italic;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">硬件描述性语言</span></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-style:italic;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">数字模块</span></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-style:italic;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">处理器体系结构</span></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-style:italic;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">微处理器体系结构</span></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-style:italic;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">存储器和输入输出系统</span></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-style:italic;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">附录</span><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-style:italic;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">数字系统实现</span></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-style:italic;font-family:Calibri;font-size:10.5pt">MIPS</span><span style="font-style:italic;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">指令</span></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-style:italic;font-family:Calibri;font-size:10.5pt">MIPS</span><span style="font-style:italic;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">处理器的</span><span style="font-style:italic;font-family:Calibri;font-size:10.5pt">FPGA</span><span style="font-style:italic;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">实现</span></li></ul></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">课程计划：学会如何设计和构造一个微处理器，而这些基本技能将作为设计其他数字系统（基于</span><span style="font-family:Calibri;font-size:10.5pt">0</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">和</span><span style="font-family:Calibri;font-size:10.5pt">1</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">）的</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#0070C0">基础</span></li></ul></li><li lang="x-none" style="margin:0in;font-size:10.5pt"><span style="font-weight: bold;font-family:&quot;Microsoft YaHei&quot;;color:#002060">数字系统的一个重要特点是 其构造模块相当简单：仅包括</span><span style="font-weight:bold;font-family:Calibri;color:#002060">0</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;color:#002060">和</span><span style="font-weight:bold;font-family:Calibri;color:#002060">1</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;color:#002060">（</span><span style="font-family:&quot;Microsoft YaHei&quot;">不需要繁杂的数学或物理知识）。</span></li><li lang="x-none" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold;color:#002060">相反，设计者的最大挑战是 如何将这些简单的部件组合起来构成复杂的系统</span><span style="font-weight:bold">。</span><span style="font-weight:bold;color:#0070C0">因此，如何控制复杂性是贯穿的一个主题。</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:12.0pt; color:#0070C0"> </li><li lang="x-none" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:12.0pt; color:#0070C0"><span style="font-weight:bold">控制复杂性的艺术</span></li><li lang="x-none" style="margin:0in;font-size:10.5pt"><span style="font-family: &quot;Microsoft YaHei&quot;">与非专业人员相比，计算机科学家或是工程师的一个重要的特征是</span> <span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;color:#002060">掌握了系统地控制复杂性的方法，且在不陷入细节的情况下构造微处理器系统</span><span style="font-family:&quot;Microsoft YaHei&quot;">。俗语有</span><span style="font-family: Calibri">“</span><span style="font-family:&quot;Microsoft YaHei&quot;">不可能照顾到每一个人</span><span style="font-family:Calibri">”</span><span style="font-family:&quot;Microsoft YaHei&quot;">就是如此。</span></li><li lang="x-none" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#00B0F0"><span style="font-weight:bold">抽象</span></li><li lang="x-none" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">管理复杂性的关键技术在于 抽象：<span style="font-weight:bold">隐藏不重要的细节</span>。一个系统可以从多个不同的层面（包括深度）进行抽象。</li><li lang="x-none" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">一个电子计算机系统的抽象层次（典型模块）：</li><li lang="x-none" style="margin:0in;font-family:Calibri;font-size:11.0pt"> </li><li lang="x-none" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">物理层 器件层 模拟电路 数字电路 逻辑层 微体系结构 体系结构 操作系统 应用层</li><li lang="x-none" style="margin:0in;font-family:Calibri;font-size:11.0pt"> </li><li lang="x-none" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">电子 晶体管 放大器 与门 加法器 数据路径 指令 设备驱动 应用软件</li><li lang="x-none" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">二极管 滤波器 或门 存储器 控制器 寄存器 内核
<ul style="margin-left:0in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">最底层的抽象是物理层，即电子的运动由量子力学和麦克斯韦方程来描述。</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">这是以方程的形式来对物理运动的一个抽象描述。</span></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">器件层则是通过明确定义的端子来连接外部，并建立和使用每个端子上的电压和电流之间的关系模型。</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">通过器件级的抽象，我们可以忽略单个电子在器件内部的特定运动。</span></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">更高一层的抽象是模拟电路。在这一级中，器件</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">组合</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">在一起构造出放大器等组件（</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">这是建立输入和输出模型来对以上所作出的抽象，并且输入和输出都是连续的电压值</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">）。</span></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">数字电路（逻辑门等）则是将电压控制在离散的范围内，以</span><span style="font-family:Calibri;font-size:10.5pt">“</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">表示</span><span style="font-family:Calibri;font-size:10.5pt">”0</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">和</span><span style="font-family:Calibri;font-size:10.5pt">1</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">。</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">这是以人工规则的形式来对连续到离散的一个抽象。</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">当然，通过一定的</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">逻辑规则</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">我们可以使用数字电路构造出更复杂的结构。</span></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">微体系结构是将逻辑层和体系结构层连接在一起的抽象</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">。</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt;color:#00B050">体系结构层描述了程序员观点的计算机抽象</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">。例如</span> <span style="font-size: 11pt;"><span style="font-family: Calibri;"><span style="font-family:Calibri;font-size:10.5pt">Intel x86</span></span></span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">体系结构定义了一整套指令系统和寄存器，程序员可以直接编辑它们便可实现一定的功能（汇编语言）。</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt;color:#00B050">微体系结构则是将逻辑元素组合在一起来实现体系结构层中定义的指令</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">。</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt;color:#00B0F0">一个特定的体系结构可以有不同的微体系结构</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">。例如：</span><span style="font-family:Calibri;font-size:10.5pt">x86</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">体系结构中分有</span> <span style="font-size: 11pt;"><span style="font-family: Calibri;"><span style="font-family:Calibri;font-size:10.5pt">Intel Core i7</span></span></span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">，</span><span style="font-family:Calibri;font-size:10.5pt">Intel 80486</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">，</span><span style="font-family:Calibri;font-size:10.5pt">AMD Athlon</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">等。</span></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">此后则是进入软件层面。</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">操作系统负责处理底层硬件的抽象</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">（访问硬盘或管理存储器）而</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">应用层</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">则是使用操作系统所提供的这些功能来解决用户的问题，换句话说就是</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">将用户的需求抽象成操作系统的原有功能的一系列组合。</span></li></ul></li><li lang="x-none" style="margin:0in;font-size:10.5pt;color:#00B0F0"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;">我们主要描述从数字电路到体系结构之间的抽象层次。而在处于某个抽象层次时，确保对上一层或是下一层有一定的了解。选择正确的层次来解决问题，同时评估自己的</span><span style="font-weight:bold;font-family:Calibri">‘</span><span style="font-weight: bold;font-family:&quot;Microsoft YaHei&quot;">设计选择</span><span style="font-weight:bold; font-family:Calibri">’</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;">对其他抽象层的影响。</span></li><li lang="x-none" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:12.0pt; color:#00B0F0"><span style="font-weight:bold">约束</span></li><li lang="x-none" style="margin:0in;font-size:10.5pt"><span style="font-weight: bold;font-family:&quot;Microsoft YaHei&quot;;color:#002060">约束是对</span><span style="font-weight:bold;font-family:Calibri;color:#002060">‘</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;color:#002060">设计选择</span><span style="font-weight:bold;font-family:Calibri;color:#002060">’</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;color:#002060">的一种内在限制、标准，通过这种限制可以更高效的在</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;color:#00B0F0">更高的抽象层次</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;color:#002060">上工作。</span><span style="font-family:&quot;Microsoft YaHei&quot;">而使用可互换部件是约束的一种：基于可互换部件的约束，将零件限定为一个误差允许范围内的标准集合；而将部件进行组合也不用考虑较低层次的抽象。</span></li><li lang="x-none" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#002060">同理数字电路也是如此（离散电压是连续电压的一个约束子集，应用范围较弱但设计简单）。</li><li lang="x-none" style="margin:0in;font-size:12.0pt;color:#00B0F0"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;">三</span><span style="font-weight:bold;font-family:Calibri">Y</span><span style="font-weight: bold;font-family:&quot;Microsoft YaHei&quot;">原则</span></li><li lang="x-none" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">除了抽象和约束外，还需要三条准则来处理系统的复杂性：<span style="font-weight:bold; color:#002060">层次化、模块化和规整化</span>（通用于软硬件）。
<ul style="margin-left:0in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle;color:#0070C0"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">层次化：将系统划分成若干模块，然后更进一步的划分每个模块；直至这些模块可以容易理解。</span></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle;color:#0070C0"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">模块化：所有的模块都要有明确定义的功能和接口，以便于它们之间可以很容易的相互连接而不会产生意想不到的副作用。</span></li><li lang="x-none" style="margin-top:0;margin-bottom:0;vertical-align:middle;color:#0070C0"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">规整化：在模块之间寻求一致。可互换（通用）模块可以重复使用多次，以便减少设计不同模块的数量。</span></li></ul></li><li lang="x-none" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#00B0F0"><span style="font-weight:bold">数字电路分为组合电路和时序电路。</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">组合电路的输出仅仅取决于输入值。即组合当前输入值来确定输出值。</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">时序电路的输出取决于当前输入值和之前输入值。即它看中输入的序列。</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">所以说，组合电路是没有记忆的，而时序电路是有记忆的。</li><li lang="x-none" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </li><li style="margin:0in;font-family:微软雅黑;font-size:10.5pt; color:black">数字逻辑电路的成功设计人员：
<ol style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in;font-family:微软雅黑;font-size:10.5pt; font-weight:normal;font-style:normal" type="1"><li style="margin-top:0;margin-bottom:0;vertical-align:middle; color:black" value="1"><span style="font-family:微软雅黑;font-size:10.5pt;font-weight: normal;font-style:normal;font-family:微软雅黑;font-size:10.5pt">理解数字逻辑基本概念，了解传统</span><span style="font-family:微软雅黑;font-size:10.5pt;font-weight:bold;font-style: italic;font-weight:bold;font-style:italic;font-family:微软雅黑;font-size: 10.5pt">人工数字设计方法；</span><span style="font-family:微软雅黑;font-size:10.5pt; font-weight:normal;font-style:normal;font-family:微软雅黑;font-size:10.5pt; background:white">（便于直观了解数字电路的工作原理；解释CAD执行操作的类型，便于正确评估设计自动化的优势）。</span><span style="font-family:微软雅黑;font-size:10.5pt;font-weight:normal;font-style: normal;font-family:微软雅黑;font-size:10.5pt">虽然只有极少数场合使用。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle;color:black"><span style="font-family:微软雅黑;font-size:10.5pt">熟练使用计算机辅助工具CAD，掌握现代数字电路设计方法。</span></li></ol></li><li style="margin:0in;font-family:微软雅黑;font-size:10.5pt;color:black">现代数字电路的实现技术：<span style="background:white">  重点在于可编程逻辑器件 PLD。</span></li><li style="margin:0in;font-family:微软雅黑;font-size:10.5pt;color:black">   两种最常用的PLD：复杂可编程逻辑器件CPLD；现场可编程门阵列FPGA。</li><li style="margin:0in;font-family:微软雅黑;font-size:10.5pt;color:black">我所总结的计算机体系结构：</li><li style="margin:0in"><span style="font-size: 11pt;"><span style="font-family: Calibri;"><img src="深入系列_files/Image.jpg" type="image/jpeg" alt="物 理 表 示 功 能 表 示 并 行 组 合 逻 辑 时 序 逻 辑 物 理 表 示 地 址 标 识 功 能 表 示 状 态 配 詈 层 级 串 行" height="270" style="height: auto;" width="480"/></span></span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </li><li style="margin:0in;font-family:Calibri;font-size:11.0pt"> </li><li style="margin:0in;font-size:14.0pt"><span lang="en-US" style="font-weight:bold; font-family:Calibri">HDL</span><span lang="zh-CN" style="font-weight:bold; font-family:&quot;Microsoft YaHei&quot;">引言</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:14.0pt"> </li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">组合电路和时序电路的设计可以从两个方面进行讨论。</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">1 原理图层面：需通过手动简化<span style="font-weight:bold">真值表和布尔表达式</span>的方法来寻找一套有效的<span style="font-weight:bold;color:#002060">逻辑门</span>电路来实现给定的功能；并且还需手工将<span style="font-weight:bold">有效状态机</span>转换为<span style="font-weight:bold; color:#002060">逻辑门</span>。对硬件的说明通常由<span style="font-weight:bold;color:#002060">电路图</span>给出。</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">2 抽象层层面：只说明<span style="font-weight:bold">逻辑功能</span>，并引入CAD工具来生成<span style="font-weight:bold;color:#002060">逻辑门</span>电路。对硬件的说明通常由硬件描述性语言<span style="font-weight:bold;color:#002060">HDL</span>给出。</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#00B0F0"><span style="font-weight:bold">硬件可以由电路图和HDL两种形式表示。</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#0070C0"><span style="font-weight:bold">模块</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">包括<span style="font-weight:bold;color:#0070C0">输入</span>和<span style="font-weight: bold;color:#0070C0">输出</span>的硬件块称为模块。与门，复用器和优先级电路都是模块的例子。</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">描述模块功能的主要形式有两种：<span style="font-weight:bold">行为模型（一个模块做什么）</span>和 <span style="font-weight:bold">结构模型（层次化：一个模块怎样由更简单的部件构造）</span>。</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#00B0F0"><span style="font-weight:bold">模块是模块化的一个应用。它定义了由输入和输出组成的接口，以及所执行的特定功能。而其编码内容对于调用该模块的其他模块并不重要。</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#0070C0"><span style="font-weight:bold">SystemVerilog/.sv与VHDL/.vhd</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">两种语言都足以描述任何的硬件系统，也都有各自的特点。现今大部分CAD工具都允许混用这两种语言</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#00B0F0"><span style="font-weight:bold">不同的模块可以用不同的语言描述。而并不是所有的VHDL都被CAD工具支持。</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#0070C0"><span style="font-weight:bold">模拟和综合</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">这是两种硬件描述性语言的主要目的所在。
<ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">模拟阶段，给模块增加输入，并检查输出以便验证模块操作是否正确。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">综合阶段，将模块的文字描述转换为逻辑门。</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"> </li><li style="margin:0in;font-size:14.0pt"><span lang="en-US" style="font-weight:bold; font-family:Calibri">HDL</span><span lang="zh-CN" style="font-weight:bold; font-family:&quot;Microsoft YaHei&quot;">模型</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:14.0pt"> </li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Verilog HDL modeling language supports three kinds of modeling styles: <span style="font-weight:bold">gate-level, dataflow, and behavioral</span>.</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">The gate-level and datafow modeling are used to model combinatorial circuits whereas the behavioral modeling is used for both combinatorial and sequential circuits</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:16.5pt"><span style="font-weight:bold">Gate-level Modeling</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Verilog HDL supports built-in primitive gates modeling.</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">The gates supported are multiple-input, multiple-output, tristate, and pull gates.
<ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">The multiple-input gates supported are:</span> <span style="font-weight:bold;font-family: &quot;Microsoft YaHei&quot;;font-size:10.5pt">and, nand, or, nor, xor, and xnor</span> <span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">whose number of inputs are two or more, and has only one output.</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">The multiple-output gates supported are</span> <span style="font-weight:bold; font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">buf and not</span> <span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">whose number of output is one or more, and has only one input.</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">The language also supports modeling of</span> <span style="font-weight:bold;font-family: &quot;Microsoft YaHei&quot;;font-size:10.5pt">tri-state</span> <span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">gates which include</span> <span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt">bufif0, bufif1, notif0, and notif1</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">.These gates have one input, one control signal, and one output.</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">The pull gates supported are</span> <span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt">pullup and pulldown</span> <span style="font-family: &quot;Microsoft YaHei&quot;;font-size:10.5pt">with a single output (no input) only.</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">The basic syntax for each type of gates with <span style="font-weight:bold;color:#002060">zero delays</span> is as follows:
<ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">and | nand | or | nor | xor | xnor [instance name] (out, in1, …, inN); // [] is optional and | is selection</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">buf | not [instance name] (out1, out2, …, out2, input);</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">bufif0 | bufif1 | notif0 | notif1 [instance name] (outputA, inputB, controlC);</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">pullup | pulldown [instance name] (output A);</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">One can also have <span style="font-weight:bold;color:#002060">multiple instances</span> of the same type of gate in one construct separated by a comma such as
<ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">and [inst1] (out11, in11, in12), [inst2] (out21, in21, in22, in23), [inst3] (out31, in31, in32, in33);</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">The language also allows the <span style="font-weight:bold;color:#002060">delays</span> to be expressed when instantiating gates. The delay expressed is from input to output. The delays can be expressed in form of <span style="font-weight:bold">rise, fall, and turn-off</span> delays; one, two, or all three types of delays can be expressed in a given instance expression. The turn-off delay is applicable to gates whose output can be turned OFF(.e.g. notif1). For example,
<ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">and #5 A1(Out, in1, in2); // the rise and fall delays are 5 units</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">and #(2,5) A2(out2, in1, in2); // the rise delay is 2 unit and the fall delay is 5 units</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">notif1 #(2, 5, 4) A3(out3, in2, ctrl1); //the rise delay is 2, the fall delay is 5, and the turnoff delay is 4 unit</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">The gate-level modeling is useful when a circuit is a <span style="font-weight: bold;color:#002060">simple combinational</span>, as an example a multiplexer.（多路复用器）</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Multiplexer is a simple circuit which connects one of many inputs to an output. In this part, you will create a simple 2-to-1 multiplexer and extend the design to multiple bits.</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:16.5pt"><span style="font-weight:bold">Dataflow Modeling</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Dataflow modeling style is mainly used to describe <span style="font-weight:bold; color:#002060">combinational circuits</span>. The basic mechanism used is the continuous assignment. （连续赋值）In a continuous assignment, a value is assigned to a data type called <span style="font-weight:bold">net</span>.（数据类型）</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">The syntax of a continuous assignment is：
<ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">assign [delay] LHS_net = RHS_expression;</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Where LHS_net is a destination net of one or more bit, and RHS_expression is an expression consisting of various operators.</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold">The statement is evaluated at any time any of the source operand value changes and the result is assigned to the destination net after the delay unit.</span> （任意）The gate level modeling examples listed in Part 1 can be described in dataflow modeling using the continuous assignment.</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">For example,
<ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">assign out1 = in1 &amp; in2; // perform and function on in1 and in2 and assign the result to out1</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">assign out2 = not in1;</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">assign #2 z[0] = ~(ABAR &amp; BBAR &amp; EN); // perform the desired function and assign the result after 2 units</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">The <span style="font-weight:bold;color:#002060">target</span> in the continuous assignment expression can be one of the following:</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;"><span style="font-size: 10.5pt">1. A scalar net (e.g. 1</span><span style="font-size:6.75pt">st</span> <span style="font-size:10.5pt">and 2</span><span style="font-size:6.75pt">nd</span> <span style="font-size:10.5pt">examples above) 标量</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">2. Vector net 向量</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;"><span style="font-size: 10.5pt">3. Constant bit-select of a vector (e.g. 3</span><span style="font-size:6.75pt">rd</span> <span style="font-size:10.5pt">example above) 索引</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">4. Constant part-select of a vector 切片</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">5. Concatenation of any of the above</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Let us take another set of examples in which a scalar and vector nets are declared and used：
<ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">wire COUNT, CIN; // scalar net declaration</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">wire [3:0] SUM, A, B; // vector nets declaration</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">assign {COUT,SUM} = A + B + CIN; // A and B vectors are added with CIN and the result is assigned to a concatenated vector of a scalar and vector nets</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Note that multiple continuous assignment statements are not allowed on the same destination net。（不能给同一个对象连续赋值）</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:16.5pt"><span style="font-weight:bold">Behavioral Modeling</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Behavioral modeling is used to describe <span style="font-weight:bold;color:#002060">complex circuits</span>. It is primarily used to model <span style="font-weight:bold; color:#002060">sequential</span> circuits,but can also be used to model pure <span style="font-weight:bold;color:#002060">combinatorial</span> circuits. The mechanisms (statements) for modeling the behavior of a design are:
<ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">initial Statements</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">always Statements</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">procedural statements</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">A module may contain an arbitrary number of initial or always statements and may contain one or more procedural statements within them.
<ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">They are executed concurrently （非阻塞）(i.e. to model parallelism such that the order in which statements appear in the model does not matter) with respect to each other whereas the procedural statements are executed sequentially （阻塞）(i.e. the order in which they appear does matter).</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Both initial and always statements are executed at <span style="font-weight:bold">time=0</span> and then only always statements are executed during <span style="font-weight: bold">the rest of the time</span>. The syntax is as follows:
<ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">initial [timing_control] procedural_statements;</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">always [timing_control] procedural_statements;//timing_control：电平触发和边沿触发</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">where a procedural_statement is one of:
<ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">commend_ assignment</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">conditional_ifelse_statement</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">case_statement</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">loop_statement</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">wait_statement</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">The <span style="font-weight:bold">initial</span> statement is non-synthesizable and is normally used in <span style="font-weight:bold;color:#002060">testbenches</span>. The <span style="font-weight:bold">always</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">statement is <span style="font-weight:bold;color:#002060">synthesizable</span>, and the resulting circuit can be a combinatorial or sequential circuit.</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">EG:In order for the model to generate a <span style="font-weight:bold;color:#002060">combinatorial circuit</span>, the always block (i) should not be edge sensitive, (ii) every branch of the conditional statement should define all output, and (iii) every case of case statement should define all output and must have a default case.<span style="font-weight:bold">(3)</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">More detailed coverage of this topic is covered in Lab 7.</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">The destination (LHS) should be of reg type; either scalar or vector. For example,
<ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">reg m; // scalar reg type</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">reg [7:0] switches; // vector reg type</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Here is an example of a 2-to-1 multiplexer model. Note that begin and end statements in this example are redundant. They are included for <span style="font-weight: bold;color:#002060">better readability</span>.</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:16.5pt"><span style="font-weight:bold">Mixed-design Style Modeling</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Complex systems can be described in Verilog HDL using mixed-design style modeling. This modeling style supports hierarchical description（分层描述）. The design can be described using:
<ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Build-in gate primitives （原语）(gate-level modeling covered in Part 1)</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Dataflow modeling (covered in Part 2)</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Behavioral modeling (covered in Part 3)</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Module instantiation （例化）</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Combinations of the above.</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold">Interconnections between various objects are done through nets (of type wire)（对应于连续赋值）. Nets may be scalar or vector.</span> For example,
<ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">wire y; // scalar net</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">wire [3:0] sum; // vector net</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">In absence of size, the net is assumed to be the scalar type.</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:16.5pt"><span style="font-weight:bold">Conclusion</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">In this lab, you created PlanAhead projects to develop various models. You implemented the design and verified the functionality in hardware as well as simulation. You learned three modeling styles. The gatelevel and dataflow modeling are primarily used for the combinatorial circuits, whereas the behavioral modeling supports both combinatorial and sequential circuits design. In this lab you used the behavioral modeling for the combinatorial circuits design. In next few labs you will be using dataflow modeling for designing various combinatorial circuits, and starting with Lab 7, you will use the behavioral modeling to</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">design sequential circuits.</li><li lang="x-none" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:14.0pt"><span style="font-weight:bold">补充</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:14.0pt"> </li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Spice文件是由一系列电路<span style="font-weight:bold">描述行</span>和<span style="font-weight:bold">控制行</span>组成的。</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:12.0pt; color:#002060"><span style="font-weight:bold">基本语句</span></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">主要针对元件、半导体器件、电源等组成的电路进行分析。包括直流分析（静态工作点、非线性电路、小信号传输函数）、交流小信号分析（频域分析、噪声分析）；瞬态分析、温度特性分析等。</span><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">标题</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">：描述文件功能。SPICE将第一行作为标题行而不参与电路的模拟仿真。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">注释</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">：格式为“ * ”后加字符串。可以存在于除第一行和最后一行之间的任何位置并不参与电路的模拟仿真。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">描述行</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">：定义电路拓扑结构、元件类型及数值。可以存在于除第一行和最后一行之间的任何位置。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">控制行</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">：对电路特性进行选择分析、对输出等设置要求。可以存在于除第一行和最后一行之间的任何位置。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">结束</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">：标志结束。格式为 .END。位于最后一行。</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:12.0pt; color:#002060"><span style="font-weight:bold">描述行</span><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">名称8</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">：第一位是A-Z的某个字母（元器件名称的首字母），而其它位没有限制。</span></li></ul></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt">【电路中每个元器件需要以器件语句进行描述。句中第一个字母是关键字，用于确定器件类型】
<ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">节点编号</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">：一般采用正整数，也可以使用字符串。但接地点必须为0。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">元件参数值</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">：其值可用整数/浮点数， 并可跟比例因子和单位后缀。元件值的第一个后缀是比例因子，然后是单位后缀。比例因子后缀与它前面的数相乘后即得到该语句所描述的元件的参数值。</span><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">如果没有比例因子后缀，那么头一个后缀就可能是单位后缀，但Spice总是忽略单位后缀。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">在没有比例后缀和单位后缀的情况下，电压、电流、频率、电感、电容和角度的量纲默认为 伏、安、赫、亨、法和度。</span></li></ul></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">分隔符</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">：用以区分一行语句的不同部分。 空格、逗号、等号、左括号、右括号等都可以作为分隔符，多余的分隔符是无效的。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">续行号</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">： 一般一行最多有80个字符。 第二行的开始加上“＋”号，表示是第一行的继续。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">方向</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">： 规定支路电路的正方向和支路电压的正方向一致。</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#00B0F0"><span style="font-weight:bold">元器件描述行（等效电路）</span></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">结合几点因素：选取不同模型的精度、参数数量。</span><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">元件</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">分为线性元件（电阻、电容、电感、恒流源等）和非线性元件（二极管、三极管、MOS管等）。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">元件模型</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">分为物理模型（根据元件内部物理特性来构造模型，如电阻、电容）和宏模型（根据元件I/O特性来构造模型，如运放）。</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold">[]代表可选。</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold">定义MODEL</span> <span style="font-weight:bold; color:red">.MODEL</span> <span style="font-weight:bold">modelname</span> <span style="font-weight:bold;color:#0070C0">function(</span><span style="font-style: italic;color:#C69500">model parameter</span> <span style="font-weight:bold; color:#0070C0">)</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold">调用MODEL</span> <span style="font-weight:bold; color:red">.LIB</span> <span style="font-weight:bold;color:#0070C0">xx.LIB</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#7030A0"><span style="font-weight:bold">电阻</span></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">格式 R name node+ node- [modelname] value</span><ul style="margin-left:.75in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">node+ -是电阻所连接的正负节点编号。当加持正电压时，电流从node+流入到node-。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">modelname是模型名，其定义由.MODEL语句，其调用由.LIB语句。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">value是电阻数值（欧），可正负。</span></li></ul></li><li style="display:inline;list-style:none;"><ul style="margin-left:.75in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li style="margin-top:0;margin-bottom:0;vertical-align:middle;color:#0070C0"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#0070C0">function：</span><span style="font-weight:bold;font-family: &quot;Microsoft YaHei&quot;;font-size:10.5pt;color:black">RES（R= TC1= TC2= ）</span></li></ul></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">RES=value*R*(1+TC1(T-T0)+TC2*(T-T0)^2)</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#7030A0"><span style="font-weight:bold">电容</span></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">格式 C name + - [modname] value IC=V0</span><ul style="margin-left:.75in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">（法）</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">IC定义电容的初始电压V0（时间为0）。</span></li></ul></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">而只有在瞬态分析语句.TRAN中的关键字UIC规定 时，初始条件才起作用。</span><ul style="margin-left:.75in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li style="margin-top:0;margin-bottom:0;vertical-align:middle;color:#0070C0"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#0070C0">function：</span><span style="font-weight:bold;font-family: &quot;Microsoft YaHei&quot;;font-size:10.5pt;color:black">CAP（C= VC1= VC2= TC1= TC2=）</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#7030A0"><span style="font-weight:bold">电感</span></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">格式 L name + - [modname] value IC=I0</span><ul style="margin-left:.75in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li style="margin-top:0;margin-bottom:0;vertical-align:middle;color:#0070C0"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#0070C0">function：</span><span style="font-weight:bold;font-family: &quot;Microsoft YaHei&quot;;font-size:10.5pt;color:black">IND（L= IL1= IL2= TC1= TC2= ）</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#7030A0"><span style="font-weight:bold">【半导体电阻，半导体电容、半导体电感、互感、传输线】</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#7030A0"><span style="font-weight:bold">二极管</span></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">格式 D name + - modname [value-area]</span><ul style="margin-left:.75in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li style="margin-top:0;margin-bottom:0;vertical-align:middle;color:#0070C0"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#0070C0">function：</span><span style="font-weight:bold;font-family: &quot;Microsoft YaHei&quot;;font-size:10.5pt;color:black">D（具体参数见表 ）</span></li></ul></li><li style="display:inline;list-style:none;"><ul style="margin-left:.75in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">value-area代表截面尺寸</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#7030A0"><span style="font-weight:bold">双极结型晶体管</span></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">格式 Q name nc nb ne [ns] modname [value-area]</span><ul style="margin-left:.75in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">ns代表衬底节点，默认接地。nc代表集电极，nb代表基极，ne代表发射极</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">Pspice中双极结型晶体管采用EM和GP模型，其模型参数多达40</span></li></ul></li><li style="display:inline;list-style:none;"><ul style="margin-left:.75in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li style="margin-top:0;margin-bottom:0;vertical-align:middle;color:#0070C0"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#0070C0">function：</span><span style="font-weight:bold;font-family: &quot;Microsoft YaHei&quot;;font-size:10.5pt;color:black">NPN/PNP（模型参数参上）</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#7030A0"><span style="font-weight:bold">【结型场效应管、MOS场效应管、砷化镓场效应管】</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#00B0F0"><span style="font-weight:bold">电压源和信号源</span></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt;color:#00B0F0"><span style="font-weight:bold">电压源、电流源可以是独立源，也可以是受控源。独立源可分为直流源DC，交流小信号源AC和瞬 态源。而瞬态源又有正弦SIN、脉冲PULSE、指数EXP、分段线性PWL、单品调频SFFM等几种形式。</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#7030A0"><span style="font-weight:bold">独立电压源</span></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">格式 V name + - [ [DC] value ]</span></li><li style="margin:0in;margin-left:1.5in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">[ [AC] [振幅值][相位值][瞬时值] ]</span></li><li style="margin:0in;margin-left:1.5in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">瞬时值：[PULSE] [SIN] [EXP] [PWL] [SFFM]</span><ul style="margin-left:.75in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">SIN（V0 VA FREQ TD ALPHA THETA）</span></li></ul></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">分别为偏置电压、电压振幅、频率、延迟时间、阻尼因子、相位延迟</span><ul style="margin-left:.75in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">PULSE（V1 V2 TD TR TF PW PER）</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold">分别为初始电压、脉冲电压、延迟时间、上升时间、下降时间、脉冲宽度、脉冲周期</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#00B0F0"><span style="font-weight:bold">子电路描述语句</span></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">定义格式 .SUBCKT subname n1[n2 n3 ... ]</span></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">定义子电路的元器件描述行</span></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">.ENDS</span><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">subname是子电路名。n1,n2 ... 是子电路外部节点号（非0）。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">子电路定义语句中不能出现 控制语句。但可包括器件模型，子电路调用，其他子电路定义。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">局部（节点号、器件名、MODEL说明）</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">全局（接地点）</span></li></ul></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">调用格式 .X [name] n1[ n2 n3 ... ] subname</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#00B0F0"><span style="font-weight:bold">元器件库文件调用语句</span></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">格式 .LIB [file name][file address]</span><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">.LIB语句调用存在于库文件中的模型或子电路库。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">file name 默认值为 NOM.LIB（引导查找其他的库文件）</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#00B0F0"><span style="font-weight:bold">文件包含语句</span></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">格式 .INC [file name]</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:12.0pt; color:#002060"><span style="font-weight:bold">控制行（电路特性分析）</span><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">指定分析类型，如直流、交流、瞬态、噪声、温度、失真分析等</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">控制语句包括初始状态设置、参数分析、输出格式和任选项语句</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">分析/控制语句都必须以 . 开头。各语句次序无关且可重复，但程序对同一类语句只执行一次。</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold;color:#7030A0">直流工作点分析</span> <span style="font-weight: bold">.OP</span><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">计算并打印电路的静态工作点</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">所有电感短路，电容开路</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">在瞬态和交流分析前程序将自动进行直流工作点分析，以确定</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#C00000">瞬态分析的初始条件和交流小信号分析时非线性器件的线性化小信号模型参数</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">输出结果：所有节点电压； 所有电压源的电流及电路的直流总功耗； 所有晶体管各级的电流和电压；非线性受控源的小信号参数</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold;color:#7030A0">直流扫描分析</span> <span style="font-weight: bold">.DC 扫描源1 初始值 终止值 步进 [2 ... ]</span><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">电压源/电流源</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">定义对电路进行直流扫描的扫描源及扫描限制</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold;color:#7030A0">交流特性分析</span> <span style="font-weight: bold">.AC DEC ND 初始频率 终止频率</span></li><li style="margin:0in;margin-left:.75in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">.AC OCT NO 初始频率 终止频率</span></li><li style="margin:0in;margin-left:.75in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">.AC LIN NP 初始频率 终止频率</span><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">计算电流在给定频率范围内的频率响应</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">ND/NO/NP 该范围内采样点的数目</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">DEC 十倍频</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">OCT 二倍频</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">LIN 线性扫描</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#7030A0"><span style="font-weight:bold">瞬态特性分析</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold">.TRAN/OP 时间增量 终止时间 [初始时间（默认0）] [最大步进] [表示用户自定义初始条件]</span><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">计算电路的瞬时特性响应</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">带有OP后缀时，能打印出由.OP语句产生的偏置点</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#7030A0"><span style="font-weight:bold">其他分析语句</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:12.0pt; color:#00B0F0"><span style="font-weight:bold">输出控制</span></li><li style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">输出各类信息</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold;color:#7030A0">文本打印语句</span> <span style="font-weight: bold">.PRINT TYPE OV1[ OV2... ]</span><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">TYPE为指定输出分析类型（直流、交流、瞬态、噪声、温度、失真分析等）</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">OV1为输出变量名</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold;color:#7030A0">绘图包调用语句</span> <span style="font-weight: bold">.PROBE</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold;color:#7030A0">文本绘图语句</span> <span style="font-weight: bold">.PLOT TYPE OV1[ OV2... ]</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold;color:#7030A0">重置参数语句</span> <span style="font-weight: bold">.OPTIONS OPT=VAL ...</span></li><li style="margin:0in;margin-left:.75in;font-family:&quot;Microsoft YaHei&quot;; font-size:10.5pt"><span style="font-weight:bold">.OPTIONS OPT1 OPT2</span><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">修改仿真控制参数，以调整仿真精度、速度或某些器件的默认参数</span></li></ul></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:12.0pt; color:#00B0F0"><span style="font-weight:bold">其他补充</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold">元器件名称的首字母</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#C00000">B：砷化镓-场效应管</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#C00000">J：结型-场效应管</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#C00000">M：MOS场效应管</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:red">E：电压源/电压控制</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:red">F：电流源/电流控制</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:red">G：电流源/电压控制</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:red">H：电压源/电流控制</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#C69500">D：二极管</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#C69500">Q：双极型晶体管</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#74A540">I：独立电流源</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#74A540">V：独立电压源</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#00B050">K：互感（耦合系数）</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#00B050">L：电感</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#00B050">C：电容</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#00B050">R：电阻</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#00B0F0">W：开关/电流控制</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#00B0F0">S：开关/电压控制</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#0070C0">X：子电路</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#0070C0">T：传输线</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold">比例因子后缀（当然可以直接使用数值表示）</span></li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:red">F：1E-15 法</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:red">P：1E-12 皮</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:red">N：1E-9 纳</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:red">U：1E-6 微</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:red">MIL：25.4E-6 X</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:red">M：1E-3 毫</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#7030A0">K：1E3 千</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#7030A0">MEG：1E6 X</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#7030A0">G：1E9 X</li><li style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt; color:#7030A0">T：1E12 X</li><li lang="x-none" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </li><li lang="x-none" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </li></ul></div></div></div><div style="font-family:Calibri;font-size:11.0pt"><div><p style="margin:0in"> </p><p style="text-align:left;margin:0in;font-family:Arial;font-size:9pt; color:#969696;direction:ltr">已使用 Microsoft OneNote 2016 创建。</p></div></div></span>
</div>
<hr>
<a name="603"/>

<div>
<span lang="zh-CN" style="font-family:Calibri;font-size:11.0pt"><div style="direction:ltr;border-width:100%"><div style="direction:ltr;margin-top:0in;margin-left:0in;width:8.8805in"><div style="direction:ltr;margin-top:0in;margin-left:.075in;width:1.7256in"><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei Light&quot;;font-size:20.0pt">8086外设</p></div><div style="direction:ltr;margin-top:.0388in;margin-left:.075in;width:1.9027in"><p style="margin:0in;font-size:10.0pt;color:#767676"><span style="font-family: Calibri">2016</span><span style="font-family:&quot;Microsoft YaHei&quot;">年</span><span style="font-family:Calibri">12</span><span style="font-family:&quot;Microsoft YaHei&quot;">月</span><span style="font-family:Calibri">22</span><span style="font-family:&quot;Microsoft YaHei&quot;">日</span></p><p style="margin:0in;font-family:Calibri;font-size:10.0pt;color:#767676">10:31</p></div><div style="direction:ltr;margin-top:.4895in;margin-left:0in;width:8.8805in"><p lang="en-US" style="margin:0in;font-family:微软雅黑;font-size:16.0pt"><span style="font-weight:bold">引言</span></p><p lang="en-US" style="margin:0in;font-family:微软雅黑;font-size:12.0pt"> </p><p lang="en-US" style="margin:0in"><span style="font-weight:bold;font-family: &quot;微软雅黑 Light&quot;;font-size:12.0pt">IO接口</span><span style="font-family:微软雅黑; font-size:11.0pt">：一个需要将CPU</span><span style="font-family:&quot;Microsoft YaHei&quot;; font-size:11.0pt">与</span><span style="font-family:微软雅黑;font-size:11.0pt">存储器、基本输入输出设备连接在一起的</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">（内存</span><span style="font-family:Calibri;font-size:11.0pt">/</span><span style="font-family: 微软雅黑;font-size:11.0pt">IO）总线和接口电路。具体详见深入理解计算机系统。</span></p><p lang="en-US" style="margin:0in"><span style="font-weight:bold;font-family: &quot;微软雅黑 Light&quot;;font-size:12.0pt">接口</span><span style="font-family:&quot;Microsoft YaHei&quot;; font-size:11.0pt">：解决CPU与外设之间的信息转换问题，使得二者之间的信息能够相互识别。</span></p><p lang="en-US" style="margin:0in;font-family:微软雅黑;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-size:11.0pt"><span style="font-family: &quot;Microsoft YaHei&quot;">外设和</span><span style="font-family:Calibri">CPU</span><span style="font-family:&quot;Microsoft YaHei&quot;">相比：</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">工作速度、通信方式、数据格式、时序（不匹配）</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">因此外设与CPU总线接口无法直接相连，需要IO接口。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">从编程角度来看，IO接口可以抽象为：CPU进行读写的寄存器（IO端口），各端口由端口地址标识。尤其注意端口地址分为8位和16位，唯一指定的寄存器分为AL/AX和DX。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">CPU读写端口的指令为（IN/OUT）。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">IO端口可以划分为数据、状态、控制。相应的信息均由数据总线连接至CPU总线端口。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:12.0pt"><span style="font-weight:bold">IO端口的寻址方式（端口地址）</span></p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">存储器映像：将IO空间置于内存空间，将其与存储器寻址统一。已有指令即可访问IO端口，不必单独设置IO指令。</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">IO单独编址：将IO空间与内存空间分离，不满足存储器寻址要求。IO指令独立访问。</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">当初困扰的是为什么IN/OUT指令可以在目的操作数接受立即数?</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">当然如果采用IO单独编址方式，就不得不考虑如何将IO空间的内容传送到存储器空间？<span style="background: yellow;mso-highlight:yellow">这也是接下来讨论的。</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:12.0pt"><span style="font-weight:bold">CPU与外设的数据传送方式</span></p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">程序：无条件、条件（IO指令）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">中断：（IO指令）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">DMA</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold">无条件传送（同步传送）</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">已知外设准备好，不用查询外设的状态信息，直接使用IO指令。简单设备。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">条件传送（查询方式）</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">已知外设不同步，需要查询外设的状态信息，否则就地等待。低速设备。</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">查询环节：寻址状态端口；读取状态端口相应标志位；直至就绪，否则等待。</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">传送环节：寻址数据端口；分别使用IO指令以输入输出。</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold">中断传送</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">已知外设准备好，由外设发出中断请求（更简单的说是中断类型号），CPU暂停原程序，转而执行IO指令；完成后继续执行原程序。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">这就解释了为什么中断相比程序传送效率更高？当然就随机情况而言的。低速设备（效率）。</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">可以把中断看成是效率更高的程序传送</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">中断服务程序人为设定（系统、自定义）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">CPU针对中断请求的检测：INTA引脚第一时钟（ISR置位，IRR清0）；INTA引脚第二时钟（中断类型号）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">中断类型号输入CPU：INTR引脚</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold">DMA传送</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">外设与存储器直接进行数据交换，而不通过CPU。CPU处于待机方式，并且把总线让出来给专用的端口（DMA控制器）使用。高速设备。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">可以明确的是，DMA一方面属于IO接口，另一方面能够控制总线（HOLD/HLDA）。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:14.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:16.0pt"><span style="font-weight:bold">串并行通信与接口电路（8251A/8255A）</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:14.0pt"><span style="font-weight:bold">串行通信</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">将数据分解成二进制位，并且用一条信号线一位一位的顺序传送。每一个数据位占有固定的时间长度。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">长距离、中低速。典型：RS-232、USB、IEEE1394。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">值得注意的是，收发双方必须遵守共同的通信协议，这样才能解决传送速度等问题。串行是指外设和IO电路之间的信息传送方式；CPU与IO端口仍采用并行方式工作。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">按传输方式分：全双工、半双工、单工（数据线数目）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">按时序分：同步、异步</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold;background:yellow;mso-highlight:yellow">同步通信</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><div style="direction:ltr"><table border="1" cellpadding="0" cellspacing="0" style="direction:ltr; border-collapse:collapse;border-style:solid;border-color:#A3A3A3;border-width: 1pt"><tr><td style="border-style:solid;border-color:#A3A3A3;border-width:1pt; vertical-align:top;width:.843in;padding:2.0pt 3.0pt 2.0pt 3.0pt"><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">同步字符</p></td><td style="border-style:solid;border-color:#A3A3A3;border-width:1pt; vertical-align:top;width:1.1965in;padding:2.0pt 3.0pt 2.0pt 3.0pt"><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">字符1 …字符n</p></td><td style="border-style:solid;border-color:#A3A3A3;border-width:1pt; vertical-align:top;width:.7597in;padding:2.0pt 3.0pt 2.0pt 3.0pt"><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">校验字符</p></td></tr></table></div><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">多个字符1~n组成一个数据块（数据帧）。附加一个或两个同步字符，最后以校验字符结束。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">收发双方采用同一个时钟信号进行控制，使得每一个字符均保持同步。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold;background:yellow;mso-highlight:yellow">异步通信</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><div style="direction:ltr"><table border="1" cellpadding="0" cellspacing="0" style="direction:ltr; border-collapse:collapse;border-style:solid;border-color:#A3A3A3;border-width: 1pt"><tr><td style="border-style:solid;border-color:#A3A3A3;border-width:1pt; vertical-align:top;width:.6868in;padding:2.0pt 3.0pt 2.0pt 3.0pt"><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">起始位</p></td><td style="border-style:solid;border-color:#A3A3A3;border-width:1pt; vertical-align:top;width:1.1486in;padding:2.0pt 3.0pt 2.0pt 3.0pt"><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">若干二进制位</p></td><td style="border-style:solid;border-color:#A3A3A3;border-width:1pt; vertical-align:top;width:1.4541in;padding:2.0pt 3.0pt 2.0pt 3.0pt"><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">可选的奇偶校验位</p></td><td style="border-style:solid;border-color:#A3A3A3;border-width:1pt; vertical-align:top;width:1.0854in;padding:2.0pt 3.0pt 2.0pt 3.0pt"><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">停止位（1）</p></td><td style="border-style:solid;border-color:#A3A3A3;border-width:1pt; vertical-align:top;width:1.002in;padding:2.0pt 3.0pt 2.0pt 3.0pt"><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">空闲位（1）</p></td></tr></table></div><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">一般以若干二进位表示一个字符，收发双方不用统一的时钟来控制。异步通信的数据帧仅含有一个字符。并以字符为单位，一个字符一个字符的传送，而两个字符之间的间隔是任意的。间隔以空闲位表示。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold;background:yellow;mso-highlight:yellow">串行通信的传输速率</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">波特率：通信线路上每秒钟传送的二进制位数（bps）。与时钟频率等同。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">波特率因子：收发双方的时钟频率，其为波特率的倍数。也是实际二进制位的传送速率。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold;background:yellow;mso-highlight:yellow">8251A抽象部件</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">控制端口：一般采用奇地址IO端口，但是也有例外</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">模式寄存器：决定同步、异步方式以及数据帧格式。</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">控制寄存器：使其处于规定的状态以及准备收发数据。</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">状态端口：端口地址41H</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">状态寄存器：存储标志位，反映其状态信息（查询方式）。</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">数据端口：采用偶地址IO端口</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">数据寄存器：传输数据输入输出。</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold">初始化流程</span></p><p style="margin:0in"><img src="深入系列_files/Image.png" type="image/png" alt="复 位 ： 40H 由 控 制 寄 存 器 模 式 一 同 步 ： 输 出 同 步 字 符 （ 1 一 2 ） 控 制 数 据 输 入 输 出" height="270" width="429"/></p><p lang="en-US" style="margin:0in;margin-left:1.125in;font-family:&quot;Microsoft YaHei&quot;; font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">示例：以查询方式进行初始化</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:14.0pt"><span style="font-weight:bold">并行通信</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">将一个字符的各二进制位分别用几条信号线同时传输的方式。以字长（总线宽度）为传输单位，一次传输一个字长的数据。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">短距离、高速通信。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold;background:yellow;mso-highlight:yellow">8255A抽象部件</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">控制字（相应：控制端口地址）</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">方式选择控制字</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">C端口 按位 置1/0控制字</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">方式选择控制字</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">方式0：基本IO</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">方式1：选通IO</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">方式2：双向IO</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">端口A：三种方式任意选择一种</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">端口B：方式0、1</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">端口C：控制、状态</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:14.0pt"><span style="font-weight:bold">中断通信和接口电路（8259A）</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">针对可屏蔽中断（INTR）与不可屏蔽中断（NMI）。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">8259A可以处理可屏蔽中断。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold;background:yellow;mso-highlight:yellow">辅助寄存器</span></p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">ICW</span></li><li style="list-style: none; display: inline"><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">1：芯片控制</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">2：中断类型号</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">3：主从片控制</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">4：工作方式选择</span></li></ul></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">OCW</span></li><li style="list-style: none; display: inline"><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">1：中断屏蔽（IMR）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">2：优先级、发送EOI</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">3：特殊屏蔽、状态查询</span></li></ul></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold;background:yellow;mso-highlight:yellow">工作方式</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">设置优先级</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">优先级固定<span style="mso-spacerun:yes">     </span></span></li><li style="list-style: none; display: inline"><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">普通全嵌套：IR0最高，IR7最低</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">特殊全嵌套：同上，但会响应同级中断</span></li></ul></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">优先级循环</span></li><li style="list-style: none; display: inline"><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">自动循环</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">特殊循环</span></li></ul></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">结束中断（即：让ISR对应位复位）</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">自动中断结束</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">非自动中断结束</span></li><li style="list-style: none; display: inline"><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">普通中断结束</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">特殊中断结束</span></li></ul></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">屏蔽中断源</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">普通屏蔽：IMR</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">特殊屏蔽：IMR+ISR</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">中断触发</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">边沿触发</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">电平触发</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">中断查询</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">数据线连接</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">缓冲：大系统</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">非缓冲：小</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold;background:yellow;mso-highlight:yellow">如何循环？</span></p><p lang="en-US" style="margin:0in;font-size:11.0pt"><span style="font-family: &quot;Microsoft YaHei&quot;">在优先级自动循环中，优先级初始队列由高到低为：</span><span style="font-family:Calibri">IR0~IR7</span><span style="font-family:&quot;Microsoft YaHei&quot;">（可以编程改变）。如果此时</span><span style="font-family:Calibri">IR2</span><span style="font-family:&quot;Microsoft YaHei&quot;">有中断请求，并且响应结束。之后</span><span style="font-family:Calibri">IR2</span><span style="font-family:&quot;Microsoft YaHei&quot;">优先级自动降为最低，</span><span style="font-family:Calibri">ISR3</span><span style="font-family:&quot;Microsoft YaHei&quot;">优先级最高，此时优先级队列由高到低为：</span><span style="font-family:Calibri">IR3~IR7~IR2</span><span style="font-family:&quot;Microsoft YaHei&quot;">。</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">优先级特殊循环中，与之区别在于：初始队列 就是IR0~IR7。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold;background:yellow;mso-highlight:yellow">普通中断结束</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">该方式用于全嵌套方式下，当CPU发出一条EOI指令后，即可将ISR复位。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">具体：向8259A偶地址端口写OCW2，并使其EOI=1，SL=0，R=0即可。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold;background:yellow;mso-highlight:yellow">特殊中断结束</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">该方式用于非全嵌套方式下，具体指出要清除的ISR的某位。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">具体：向8259A偶地址端口写OCW2，并使其EOI=1，SL=1，R=0即可，此时由L2/L1/L0指出复位之处。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold;background:yellow;mso-highlight:yellow">ICW初始化流程（顺序）</span></p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">124（单片）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">1234（多片级联）</span></li></ul><p lang="en-US" style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:11.0pt">ICW1：偶地址端口；ICW2~4：奇地址端口（公用）</p><p lang="en-US" style="margin:0in;margin-left:.75in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold;background:yellow;mso-highlight:yellow">OCW初始化流程（无序）</span></p><p lang="en-US" style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:11.0pt">OCW1：奇地址端口；OCW2~3：偶地址端口</p><p lang="en-US" style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:14.0pt;color:black"><span style="font-weight:bold">DMA控制器与接口电路（8237A）</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">CPU释放总线，由控制器得到总线控制权。</p><p style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold;background:yellow;mso-highlight:yellow">DMA抽象部件</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">控制寄存器（公用）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">状态寄存器（公用）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">地址寄存器（基地址，当前地址）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">字节寄存器（基字节，当前字节）</span></li></ul><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold">初始化流程</span></p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">将数据传输缓冲区的起始地址或结束地址传送到地址寄存器。</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">将字节数、字数、双字数传送到字节计数器。</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span lang="zh-CN" style="font-weight:bold;background:yellow;mso-highlight:yellow">接口电路</span><span lang="en-US" style="font-weight:bold;background:yellow;mso-highlight:yellow">8237A</span></p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">可以有4个独立通道；</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">主从性</span></li><li style="list-style: none; display: inline"><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">作为DMA（主）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">作为IO芯片（从）</span></li></ul></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold">工作模式</span></p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">单字节传输</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">块传输</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">请求传输</span></li></ul><p lang="en-US" style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:11.0pt">级联传输（芯片数：2<span style="vertical-align:super">n-1</span>；通道数：2<span style="vertical-align:super">n+1</span>）</p><p lang="en-US" style="margin:0in;margin-left:.375in;font-family:&quot;Microsoft YaHei&quot;; font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold">8237A抽象部件</span></p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">模式寄存器</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">控制寄存器</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">状态寄存器</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">请求寄存器和屏蔽寄存器</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">地址寄存器（基地址，当前地址）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">字节寄存器（基字节，当前字节）</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-size:11.0pt"><span style="font-weight: bold;font-family:&quot;微软雅黑 Light&quot;">8237A 寄存器端口地址</span><span style="font-family: &quot;Microsoft YaHei&quot;">（全部由A0~A3区分）</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;微软雅黑 Light&quot;;font-size:11.0pt"><span style="font-weight:bold">8237A初始化编程</span></p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">复位命令（总清除命令）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">基地址（当前地址）寄存器：数据块首地址</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">基字节（当前字节）寄存器：数据块的数据数目</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">模式寄存器</span></li><li style="list-style: none; display: inline"><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">工作方式，通道类型</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">传送方式</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">是否自动预置</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">修改方向</span></li></ul></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">屏蔽寄存器</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">控制寄存器</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">请求寄存器</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;margin-left:.75in;font-family:&quot;Microsoft YaHei&quot;; font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;margin-left:.75in;font-family:&quot;Microsoft YaHei&quot;; font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p></div></div></div><div><p style="margin:0in"> </p><p style="text-align:left;margin:0in;font-family:Arial;font-size:9pt; color:#969696;direction:ltr">已使用 Microsoft OneNote 2016 创建。</p></div></span>
</div>
<hr>
<a name="607"/>

<div>
<span lang="zh-CN" style="font-family:Calibri;font-size:11.0pt"><div style="direction:ltr;border-width:100%"><div style="direction:ltr;margin-top:0in;margin-left:0in;width:6.9069in"><div style="direction:ltr;margin-top:0in;margin-left:.0215in;width:1.2041in"><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:20.0pt">8086</p></div><div style="direction:ltr;margin-top:.0388in;margin-left:.0215in;width:1.9027in"><p style="margin:0in;font-size:10.0pt;color:#767676"><span style="font-family: Calibri">2016</span><span style="font-family:&quot;Microsoft YaHei&quot;">年</span><span style="font-family:Calibri">12</span><span style="font-family:&quot;Microsoft YaHei&quot;">月</span><span style="font-family:Calibri">26</span><span style="font-family:&quot;Microsoft YaHei&quot;">日</span></p><p style="margin:0in;font-family:Calibri;font-size:10.0pt;color:#767676">15:24</p></div><div style="direction:ltr;margin-top:.584in;margin-left:0in;width:6.9069in"><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:16.0pt"><span style="font-weight:bold">概述</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">1946年，世界上第一台数字式电子计算机ENIAC产生。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">1971年，INTEL公司设计了世界上第一个微处理器芯片INTEL4004。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">计算机的换代一般以<span style="font-weight:bold">CPU的字长和典型功能的微处理器芯片</span>为标准。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">按系统规模划分：单片机、微型计算机、PC机。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">按微处理器字长划分：4、16、32、64位。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:13.0pt"><span style="font-weight:bold">微处理器（CPU）</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">具有运算和控制功能。主要分有三部分：算术逻辑单元（ALU）、累加器和寄存器组、控制器。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:13.0pt"><span style="font-weight:bold">微型计算机</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">以CPU为核心，加上存储器、IO接口、系统总线组成。系统总线又有：地址、数据、控制之分。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:13.0pt"><span style="font-weight:bold">微型计算机系统</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">以微型计算机为核心，再配置相应的外设和软件组成。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:13.0pt"><span style="font-weight:bold">性能指标</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">这里解释一下字和字长的含义：</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">字是CPU内部进行数据处理的基本单位，字长是每一个字所包含的二进制位数（即计算机内部一次可处理的二进制位数）。也就是说，字没有具体的大小，视具体的计算机而定。比如：字长就有4、16、32、64之分。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">一般计算机的字长取决于通用寄存器、内存储器、ALU位数、数据总线宽度而定。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">字也可以表示为字节的二倍，即16位。视上下文而定。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">字长（位数）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">主频（CPU的时钟频率）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">内存容量和速度</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">硬盘容量</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:16.0pt"><span style="font-weight:bold"><span style="mso-spacerun:yes"> </span></span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:16.0pt"><span style="font-weight:bold">16、32位微处理器（CPU）简介（8086、Pentium）</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:16.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:16.0pt"><span style="font-weight:bold">8086</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:14.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">40引脚，双列直插式芯片。16数据线、20地址线。可寻址的存储器空间为1MB。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">抽象结构（并行）</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">总线接口部件：从内存取指令、取数据、取状态到执行部件。组成：段地址寄存器（CS/DS/SS/ES）、指令指针寄存器（IP）、20位地址加法器（逻辑地址转物理地址）、6字节指令队列缓冲器、总线控制电路（CPU与外界总线的转换电路）。</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">执行部件：指令执行（算术、逻辑运算）。组成：ALU、通用寄存器、标志寄存器。</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:13.0pt"><span style="font-weight:bold">总线周期</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">CPU通过总线对内存、IO接口进行一次访问的时间。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:13.0pt"><span style="font-weight:bold">时钟周期</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">CPU基本时间计量单位，由计算机主频决定。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">总线周期通常包括4个时钟周期，分为T1/T2/T3/T4。</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">等待周期TW：在T3和T4之间插入。</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">空闲周期TI：在两个总线周期插入。</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:14.0pt"><span style="font-weight:bold">8086的操作和时序</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:13.0pt"><span style="font-weight:bold">系统复位和启动操作</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">需要RESET信号（维持1个总线周期的高电平）。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">在FFFF0H处存放一条无条件转移指令，转到系统程序的入口处（FFFF0H~FFFFFH）。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:13.0pt"><span style="font-weight:bold">总线操作</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">CPU与内存和IO接口传送数据。</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">总线读</span></li><li style="list-style: none; display: inline"><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">T1状态：IO/M高电平表读存储器，IO/M低电平表读IO接口；ALE锁存地址信号。</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">T2状态：开始读取数据；RD信号有效。</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">T3状态：检测数据传送是否能够完成；READY信号。</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">T4状态：完成数据传送；RD信号无效。</span></li></ul></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">总线写</span></li><li style="list-style: none; display: inline"><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">同理</span></li></ul></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:13.0pt"><span style="font-weight:bold">中断操作</span></p><p style="margin:0in"><img src="深入系列_files/Image [1].png" type="image/png" alt="主 程 序 中 断 请 求 中 断 响 应 中 断 服 务 程 序 断 点 ／ ` 中 断 返 回" height="270" width="480"/></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:12.0pt"><span style="font-weight:bold">中断源</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">产生中断请求的方式（外设、内部原因）</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">硬件中断</span></li><li style="list-style: none; display: inline"><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">非屏蔽中断（NMI）：无中断响应周期、不受IF影响。中断类型号为2。</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">可屏蔽中断（INTR）：受IF影响、中断响应周期需两个总线周期，并在最后一个周期进行检测，以是否响应中断，读取中断类型号。</span></li></ul></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">软件中断（INT族）：无中断响应周期、不受IF影响。由INT指定中断类型号。无随机性。</span></li></ul><p style="margin:0in"><img src="深入系列_files/Image [2].png" type="image/png" alt="INT n 指 令 非 屏 蔽 中 断 请 求 NN'II 中 断 控 制 逻 辑 INTR 中 断 控 制 系 统 可 屏 蔽 中 断 请 求 INT 3 INTO 单 步 除 数 为 指 令 指 令 中 断 0 中 断 （ 8259A ） 软 件 中 断 硬 件 中 断" height="468" width="664"/></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:12.0pt"><span style="font-weight:bold">中断系统</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">可处理256种中断，对应的中断类型号为0~255。每一种类型的中断对应一个中断服务程序（内存）。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:12.0pt"><span style="font-weight:bold">中断向量和中断向量表</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">中断服务程序的入口地址（首地址），含CS（高字 ）:IP（低字）。占有4字节。每个中断向量对应一种中断。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">在00000H~003FFH安排中断向量，占有1K区域；形成中断向量表。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">注：中断类型号 *4 表取得指定类型的中断向量地址。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:13.0pt"><span style="font-weight:bold">最小模式下的总线保持</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:13.0pt"><span style="font-weight:bold">最大模式下的总线请求/允许</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">HOLD/HLDA信号，让出地址、数据、控制总线。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:16.0pt"><span style="font-weight:bold"><span style="mso-spacerun:yes"> </span></span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:14.0pt"><span style="font-weight:bold">8086存储器编址、IO编址</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:16.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:13.0pt"><span style="font-weight:bold">存储器地址分段（16~20/64KB~1MB）</span></p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">物理地址（单一）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">段地址</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">偏移地址</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">逻辑地址（多个）</span></li></ul><p style="margin:0in"><img src="深入系列_files/Image [3].png" type="image/png" alt="S I 一 D I BX S S C S BP I P" height="396" width="610"/></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:12.0pt"><span style="font-weight:bold">存储单元的内容</span></p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">可以是一个字节或是一个字。而每一个存储单元地址的单位是字节。所以对于字来说，低位字节放在低地址，高位字节放在高地址。但是二者统一使用同一个地址（视上下文而定）。</p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:12.0pt"><span style="font-weight:bold">CPU与存储器、IO接口之间传送数据的方式</span></p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">字操作数存放在 以偶地址开始的两个存储单元或IO接口</span></li><li style="list-style: none; display: inline"><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">低8位~偶</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">高8位~奇</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">在一个总线周期内完成16位数据传送。</span></li></ul></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">字操作数存放在 以奇地址开始的两个存储单元或IO接口</span></li><li style="list-style: none; display: inline"><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="circle"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">低8位~奇</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">高8位~偶</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">在两个总线周期内完成16位数据传送。</span></li></ul></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:13.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:13.0pt"><span style="font-weight:bold">IO编址（16/64K）</span></p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">存储器映像</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">独立编址（高4位0）</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:16.0pt"><span style="font-weight:bold">Pentium（体系结构IA-32）</span></p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">先进的体系结构</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">CISC和RISC相结合的技术</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">超标量流水线技术：</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">并行</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">&lt;取指-译码-</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">执行（U/V流水线）</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">&gt;。</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">先进的分支预测技术</span></li></ul><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p lang="en-US" style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">工作方式</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">实地址方式（逻辑地址、物理地址）（分段管理、1MB寻址内存）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">保护方式（逻辑地址、线性地址、物理地址）（分页管理、4G寻址内存）</span></li><li lang="en-US" style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt">虚拟8086方式（和8086相似，逻辑地址和线性地址等同）（先分段~1MB、再分页~4KB）</span></li></ul><p lang="en-US" style="margin:0in;font-family:Calibri;font-size:11.0pt"> </p><p style="margin:0in;font-family:微软雅黑;font-size:12.0pt;color:black"><span style="font-weight:bold">保护模式下的地址计算</span></p></div></div></div><div><p style="margin:0in"> </p><p style="text-align:left;margin:0in;font-family:Arial;font-size:9pt; color:#969696;direction:ltr">已使用 Microsoft OneNote 2016 创建。</p></div></span>
</div>
<hr>
<a name="612"/>

<div>
<span lang="zh-CN" style="font-family:Calibri;font-size:11.0pt"><div style="direction:ltr;border-width:100%"><div style="direction:ltr;margin-top:0in;margin-left:0in;width:6.5243in"><div style="direction:ltr;margin-top:0in;margin-left:0in;width:1.6631in"><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:20.0pt">汇编语言</p></div><div style="direction:ltr;margin-top:.0388in;margin-left:0in;width:1.7034in"><p style="margin:0in;font-size:10.0pt;color:gray"><span style="font-family: Calibri">2017</span><span style="font-family:&quot;Microsoft YaHei&quot;">年</span><span style="font-family:Calibri">3</span><span style="font-family:&quot;Microsoft YaHei&quot;">月</span><span style="font-family:Calibri">10</span><span style="font-family:&quot;Microsoft YaHei&quot;">日</span></p><p style="margin:0in;font-family:Calibri;font-size:10.0pt;color:gray">10:52</p></div><div style="direction:ltr;margin-top:.4743in;margin-left:0in;width:6.5243in"><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:14.0pt"><span style="font-weight:bold">基础</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:11.0pt"> </p><p style="margin:0in;font-size:10.5pt"><span style="font-weight:bold; font-family:&quot;Microsoft YaHei&quot;;color:#0070C0">引言</span><span style="font-family: &quot;Microsoft YaHei&quot;">：汇编语言是一种几乎提供了全部信息的语言。程序员可以看到正在发生的所有事情，甚至包括</span><span style="font-family:Calibri">CPU</span><span style="font-family:&quot;Microsoft YaHei&quot;">中的寄存器和标志。</span></p><p style="margin:0in;font-size:10.5pt"><span style="font-family:&quot;Microsoft YaHei&quot;">当然，程序员也必须提供</span><span style="font-family:Calibri">“</span><span style="font-family:&quot;Microsoft YaHei&quot;">数据表示的细节和指令的格式</span><span style="font-family:Calibri">”</span><span style="font-family:&quot;Microsoft YaHei&quot;">。</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">因此，从两个角度来讲，程序员和汇编语言都是工作在一个具有大量详细信息的层次。</p><p style="margin:0in;font-size:10.5pt"><span style="font-family:&quot;Microsoft YaHei&quot;">而所谓的</span><span style="font-family:Calibri">“</span><span style="font-family:&quot;Microsoft YaHei&quot;">汇编器的语法规则</span><span style="font-family:Calibri">”</span><span style="font-family:&quot;Microsoft YaHei&quot;">指的是</span><span style="font-family:Calibri">“MASM</span><span style="font-family:&quot;Microsoft YaHei&quot;">汇编器使用的语法规则</span><span style="font-family:Calibri">”</span><span style="font-family:&quot;Microsoft YaHei&quot;">。</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold;color:#0070C0">单行注释</span> 总是以分号开头。</p><p style="margin:0in;font-size:10.5pt"><span style="font-weight:bold; font-family:&quot;Microsoft YaHei&quot;;color:#0070C0">块注释</span> <span style="font-family: &quot;Microsoft YaHei&quot;">由</span><span style="font-family:Calibri">COMMENT</span><span style="font-family:&quot;Microsoft YaHei&quot;">伪指令和一个用户定义的符号说明。汇编器将忽略其后的文本行，直到相同的用户定义的符号出现为止。</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">而程序清单的开始部分通常包含如下信息：</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">程序功能的说明</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">程序创建者和修改者</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">常见和修改的日期</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">程序实现的技术</span></li></ul><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt;color:#0070C0"><span style="font-weight:bold">定义数据</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold">内部数据类型</span>：按照数据大小（字节，字，双字等），是否有符号，是整数还是实数来描述。而后两项是为汇编器识别提供的。定义数据的关键字只是限制大小，并不检查变量中存放的内容。</p><p style="margin:0in;font-size:10.5pt;color:#00B0F0"><span style="font-weight: bold;font-family:Calibri">BYTE/SBYTE</span> <span style="font-weight:bold; font-family:&quot;Microsoft YaHei&quot;">或是</span><span style="font-weight:bold; font-family:Calibri">DB</span></p><p style="margin:0in;font-size:10.5pt"><span style="font-family:&quot;Microsoft YaHei&quot;">定义字符串：以空字节</span><span style="font-family:Calibri">0</span><span style="font-family:&quot;Microsoft YaHei&quot;">作为结束标记。</span></p><p style="margin:0in;font-size:10.5pt"><span style="font-family:Calibri">DUP</span><span style="font-family:&quot;Microsoft YaHei&quot;">操作符：字符串和数组分配存储空间。格式：数据类型 元素个数</span><span style="font-family:Calibri">/</span><span style="font-family:&quot;Microsoft YaHei&quot;">符号</span> <span style="font-family:Calibri">DUP</span><span style="font-family:&quot;Microsoft YaHei&quot;">（初始值）</span></p><p style="margin:0in;font-size:10.5pt"><span style="font-family:&quot;Microsoft YaHei&quot;">计算数组和字符串的大小：显示声明容易造成编译错误（僵硬），尤其是后续还要插入或删除元素。更好地办法就是让汇编器来计算这个值。即：</span><span style="font-family:Calibri">$-list</span><span style="font-family:&quot;Microsoft YaHei&quot;">（终止</span><span style="font-family:Calibri">-</span><span style="font-family:&quot;Microsoft YaHei&quot;">起始）</span></p><p style="margin:0in;font-size:10.5pt;color:#00B0F0"><span style="font-weight: bold;font-family:Calibri">WORD/SWORD</span> <span style="font-weight:bold; font-family:&quot;Microsoft YaHei&quot;">或是</span><span style="font-weight:bold; font-family:Calibri">DW</span></p><p style="margin:0in;font-size:10.5pt;color:#00B0F0"><span style="font-weight: bold;font-family:Calibri">DWORD/SDWORD</span> <span style="font-weight:bold; font-family:&quot;Microsoft YaHei&quot;">或是</span><span style="font-weight:bold; font-family:Calibri">DD</span></p><p style="margin:0in;font-size:10.5pt"><span style="font-family:&quot;Microsoft YaHei&quot;">可以用于声明一种变量，这种变量包含的是另一个变量的</span><span style="font-family:Calibri">32</span><span style="font-family:&quot;Microsoft YaHei&quot;">位偏移量。</span></p><p style="margin:0in;font-size:10.5pt;color:#00B0F0"><span style="font-weight: bold;font-family:Calibri">QWORD</span> <span style="font-weight:bold; font-family:&quot;Microsoft YaHei&quot;">或是</span><span style="font-weight:bold; font-family:Calibri">QQ</span></p><p style="margin:0in;font-size:10.5pt;color:#00B0F0"><span style="font-weight: bold;font-family:&quot;Microsoft YaHei&quot;">定义压缩</span><span style="font-weight:bold; font-family:Calibri">BCD</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;">数据（</span><span style="font-weight:bold;font-family:Calibri">TBYTE</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;">）</span><span style="font-weight:bold;font-family:Calibri">10</span><span style="font-weight: bold;font-family:&quot;Microsoft YaHei&quot;">字节</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">常数初始值必须是十六进制。</p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt;color:#00B0F0"><span style="font-weight:bold">定义浮点类型</span></p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:Calibri;font-size:10.5pt">REAL4/8/10</span> <span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">单精度、双精度、字节扩展精度</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:Calibri;font-size:10.5pt">DD/DQ/DT</span> <span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">短实数、常实数、扩展精度实数</span></li></ul><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">注意其精度和范围是有限的。</p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold">数据定义语句</span>：在内存中为变量保留存储空间，并赋予一个可选的名字。其使用内部数据类型来定义变量。</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">名字（可选）：属于标号。标识从段的开始带该变量的偏移量。若使用了多个初始值。那么它的标号只指出第一个初始值的偏移量。在单个数据定义中，其初始值可以使用形式不一的数据。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">伪指令：内部数据类型或是传统数据伪指令</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">初始值：至少为一个。</span><span style="font-family:Calibri;font-size:10.5pt">0 ?</span> <span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">其他。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:Calibri;font-size:10.5pt">S</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">代表有符号</span></li></ul><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt;color:#0070C0"><span style="font-weight:bold">整数常量</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">由一个可选的前置符号，一个或多个数字，以及一个可选的指明其基数的字符组成。</p><p style="margin:0in;font-size:10.5pt"><span style="font-family:&quot;Microsoft YaHei&quot;">常见的基数字符包括</span><span style="font-family:Calibri">h,o,d,b</span><span style="font-family:&quot;Microsoft YaHei&quot;">。</span></p><p style="margin:0in;font-size:10.5pt"><span style="font-family:&quot;Microsoft YaHei&quot;">而以字母开头的十六进制数必须加个前置</span><span style="font-family:Calibri">0</span><span style="font-family:&quot;Microsoft YaHei&quot;">，以防汇编将其解释为标识符。</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt;color:#0070C0"><span style="font-weight:bold">整数常量表达式</span></p><p style="margin:0in;font-size:10.5pt"><span style="font-family:&quot;Microsoft YaHei&quot;">属于算术表达式，包含了整数常量和算术运算符。而结果是一个整数（最大是</span><span style="font-family:Calibri">32</span><span style="font-family:&quot;Microsoft YaHei&quot;">位）。</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">运算符优先级不必强记，可以使用圆括号来表明操作顺序。</p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt;color:#0070C0"><span style="font-weight:bold">实数常量（浮点数常量）</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">分为十进制实数和十六进制实数（编码实数）。</p><p style="margin:0in;font-size:10.5pt"><span style="font-weight:bold; font-family:&quot;Microsoft YaHei&quot;;color:#00B0F0">十进制</span><span style="font-family: &quot;Microsoft YaHei&quot;">：包含一个可选符号（</span><span style="font-family:Calibri">+ -</span><span style="font-family:&quot;Microsoft YaHei&quot;">），一个整数，一个十进制小数点，一个可选的表示小数部分的整数以及一个可选的指数。</span></p><p style="margin:0in;font-size:10.5pt"><span style="font-weight:bold; font-family:&quot;Microsoft YaHei&quot;;color:#00B0F0">十六进制</span><span style="font-family: &quot;Microsoft YaHei&quot;">：使用</span><span style="font-family:Calibri">IEEE</span><span style="font-family:&quot;Microsoft YaHei&quot;">浮点数格式表示短实数。</span></p><p style="margin:0in;font-size:10.5pt"><span style="font-family:&quot;Microsoft YaHei&quot;">不过，大多数</span><span style="font-family:Calibri">x86</span><span style="font-family:&quot;Microsoft YaHei&quot;">指令集是专门针对整数进行处理的。</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt;color:#0070C0"><span style="font-weight:bold">字符常量</span></p><p style="margin:0in;font-size:10.5pt"><span style="font-family:&quot;Microsoft YaHei&quot;">常用单引号或是双引号包含的一个字符。实质是</span><span style="font-family:Calibri">ASCII</span><span style="font-family:&quot;Microsoft YaHei&quot;">码的数值（</span><span style="font-family:Calibri">8</span><span style="font-family:&quot;Microsoft YaHei&quot;">位）。</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt;color:#0070C0"><span style="font-weight:bold">字符串常量</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">常用单引号或是双引号包含的一个字符（且含空格符）序列。嵌套引号也是允许的。</p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt;color:#0070C0"><span style="font-weight:bold">符号常量</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">为整数表达式或文本指定标识符来创建符号常量。符号不预留存储空间。运行时不改变。</p><p style="margin:0in;font-size:10.5pt"><span style="font-family:&quot;Microsoft YaHei&quot;">（同</span> <span style="font-family:Calibri">C-defin</span><span style="font-family:&quot;Microsoft YaHei&quot;">）</span></p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">等号伪指令 表示整数表达式（</span><span style="font-family:Calibri;font-size:10.5pt">32</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">位）</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:Calibri;font-size:10.5pt">EDQ</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">和</span><span style="font-family:Calibri;font-size:10.5pt">TESTEDQ</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">伪指令 表示任意文本</span></li></ul><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt;color:#00B0F0"><span style="font-weight:bold">为什么使用符号？</span></p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">增加可读性</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">当前地址计数器</span> <span style="font-family:Calibri;font-size:10.5pt">$</span> <span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">（用于给变量初始化为一个当前偏移量）</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">键盘定义 程序通常定义符号来识别常见的数字键盘代码。比如</span><span style="font-family:Calibri;font-size: 10.5pt">27</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size: 10.5pt">是</span><span style="font-family:Calibri;font-size:10.5pt">ESC</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">键的</span><span style="font-family:Calibri;font-size:10.5pt">ASCII</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">码，那么可以定义</span><span style="font-family:Calibri;font-size:10.5pt">ESC_KEY=27</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">即可</span></li></ul><p style="margin:0in;font-size:10.5pt"><span style="font-weight:bold; font-family:Calibri;color:#00B0F0">EQU</span><span style="font-family:&quot;Microsoft YaHei&quot;">：把符号和整数表达式或任意文本连接起来。</span></p><p style="margin:0in;font-size:10.5pt"><span style="font-family:&quot;Microsoft YaHei&quot;">其中格式：</span><span style="font-family:Calibri">name EQU &lt;</span><span style="font-family:&quot;Microsoft YaHei&quot;">文本</span><span style="font-family:Calibri">&gt;</span> <span style="font-family:&quot;Microsoft YaHei&quot;">或是 表达式。</span></p><p style="margin:0in;font-size:10.5pt"><span style="font-weight:bold; font-family:Calibri;color:#00B0F0">TEXTEQU</span><span style="font-family:&quot;Microsoft YaHei&quot;">：创建文本宏（文本、已有文本宏的内容、整数表达式）</span></p><p style="margin:0in;font-size:10.5pt"><span style="font-family:&quot;Microsoft YaHei&quot;">其中格式：</span><span style="font-family:Calibri">name TEXTEQU &lt;</span><span style="font-family: &quot;Microsoft YaHei&quot;">文本</span><span style="font-family:Calibri">&gt;</span> <span style="font-family:&quot;Microsoft YaHei&quot;">或是</span><span style="font-family:Calibri">%</span><span style="font-family:&quot;Microsoft YaHei&quot;">整数表达式</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt;color:#0070C0"><span style="font-weight:bold">保留字</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">不可与标识符混用，且不区分大小写（通用）。</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">指令助记符</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">寄存器名称</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">伪指令：汇编器</span><span style="font-family:Calibri;font-size:10.5pt">MASM</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">操作</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">属性：（变量）操作数的大小和使用信息</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">运算符：常量表达式</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">预定义符号：</span><span style="font-family:Calibri;font-size:10.5pt">@</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">在汇编时返回常量的整数值</span></li></ul><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt;color:#0070C0"><span style="font-weight:bold">标识符</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">用于标识变量、代码标号、常量、子程序。建议是使用描述性名称。</p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt;color:#0070C0"><span style="font-weight:bold">伪指令</span></p><p style="margin:0in;font-size:10.5pt"><span style="font-family:&quot;Microsoft YaHei&quot;">嵌入源代码中的命令。用于 定义变量、宏、子程序，为内存段分配名称，执行许多其他与汇编器相关的日常任务。其中定义变量的</span><span style="font-family: Calibri">BYTE</span><span style="font-family:&quot;Microsoft YaHei&quot;">等都是伪指令。</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">一个重要功能是：定义程序区段。</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:Calibri;font-size:10.5pt">.DATA</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">段用于定义变量</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:Calibri;font-size:10.5pt">.CODE</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">段用于包含可执行代码</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:Calibri;font-size:10.5pt">.STACK</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">段用于定义运行时的堆栈</span></li></ul><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt;color:#0070C0"><span style="font-weight:bold">指令</span></p><p style="margin:0in;font-size:10.5pt"><span style="font-family:&quot;Microsoft YaHei&quot;">由程序汇编编译后执行。汇编器将指令翻译成机器语言，并且在运行时由</span><span style="font-family:Calibri">CPU</span><span style="font-family:&quot;Microsoft YaHei&quot;">加载。（不同于</span><span style="font-family:Calibri">FPGA</span><span style="font-family:&quot;Microsoft YaHei&quot;">）</span></p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">标号（可选）</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">指令助记符（必须）</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">操作数（通常必须）：个数范围</span><span style="font-family:Calibri;font-size:10.5pt">0~3</span><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">。每个操作数可以是寄存器、内存操作数（变量，带方括号的寄存器）、整数表达式和输入输出端口。第一个为源操作数，之后为目的操作数。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">注释（可选）</span></li></ul><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt"><span style="font-weight:bold;color:#00B0F0">标号</span>：属于标识符。是指令和数据的位置标记。</p><ul style="margin-left:.375in;direction:ltr;unicode-bidi:embed; margin-top:0in;margin-bottom:0in" type="disc"><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">标号位于指令区段的前端，表示指令区段的地址（代码标号），其标号必须用冒号结束；用于跳转和循环指令的目标。</span></li><li style="margin-top:0;margin-bottom:0;vertical-align:middle"><span style="font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">标号位于变量的前端，表示变量的地址（数据标号），便于在代码中引用变量。</span></li></ul><p style="margin:0in;font-size:10.5pt;color:#0070C0"><span style="font-weight: bold;font-family:&quot;Microsoft YaHei&quot;">空操作指令（</span><span style="font-weight:bold; font-family:Calibri">NOP</span><span style="font-weight:bold;font-family:&quot;Microsoft YaHei&quot;">）</span></p><p style="margin:0in;font-family:&quot;Microsoft YaHei&quot;;font-size:10.5pt">在程序空间中占有一个字节。用于编译器和汇编器将代码对齐到有效的地址边界，使程序的加载速度更快。何为对齐呢？就是满足双字的偶数整数倍即可。</p></div></div></div><div><p style="margin:0in"> </p><p style="text-align:left;margin:0in;font-family:Arial;font-size:9pt; color:#969696;direction:ltr">已使用 Microsoft OneNote 2016 创建。</p></div></span>
</div>
<hr>
<a name="732"/>

<div>
<span><div><span style="background-color: rgb(255, 255, 255);"><span style="color: rgb(127, 127, 127);"><br/></span></span></div><div><span style="background-color: rgb(255, 255, 255);"><span style="color: #7f7f7f;">摘要：深度学习可以让那些拥有多个处理层的计算模型来学习具有多层次抽象的数据的表示。这些方法在许多方面都带来了显著的改善，包括最先进的语音识别、视觉对象识别、对象检测和许多其它领域，例如药物发现和基因组学等。深度学习能够发现大数据中的复杂结构。它是利用BP算法来完成这个发现过程的。BP算法能够指导机器如何从前一层获取误差而改变本层的内部参数，这些内部参数可以用于计算表示。深度卷积网络在处理图像、视频、语音和音频方面带来了突破，而递归网络在处理序列数据，比如文本和语音方面表现出了闪亮的一面。</span></span></div><div><p>机器学习技术在现代社会的各个方面表现出了强大的功能：从Web搜索到社会网络内容过滤，再到电子商务网站上的商品推荐都有涉足。并且它越来越多地出现在消费品中，比如相机和智能手机。</p><p>机器学习系统被用来识别图片中的目标，将语音转换成文本，匹配新闻元素，根据用户兴趣提供职位或产品，选择相关的搜索结果。逐渐地，这些应用使用一种叫深度学习的技术。传统的机器学习技术在处理未加工过的数据时，体现出来的能力是有限的。几十年来，想要构建一个模式识别系统或者机器学习系统，需要一个精致的引擎和相当专业的知识来设计一个特征提取器，把原始数据（如图像的像素值）转换成一个适当的内部特征表示或特征向量，子学习系统，通常是一个分类器，对输入的样本进行检测或分类。特征表示学习是一套给机器灌入原始数据，然后能自动发现需要进行检测和分类的表达的方法。深度学习就是一种特征学习方法，把原始数据通过一些简单的但是非线性的模型转变成为更高层次的，更加抽象的表达。通过足够多的转换的组合，非常复杂的函数也可以被学习。对于分类任务，高层次的表达能够强化输入数据的区分能力方面，同时削弱不相关因素。比如，一副图像的原始格式是一个像素数组，那么在第一层上的学习特征表达通常指的是在图像的特定位置和方向上有没有边的存在。第二层通常会根据那些边的某些排放而来检测图案，这时候会忽略掉一些边上的一些小的干扰。第三层或许会把那些图案进行组合，从而使其对应于熟悉目标的某部分。随后的一些层会将这些部分再组合，从而构成待检测目标。深度学习的核心方面是，上述各层的特征都不是利用人工工程来设计的，而是使用一种通用的学习过程从数据中学到的。</p><p>深度学习正在取得重大进展，解决了人工智能界的尽最大努力很多年仍没有进展的问题。它已经被证明，它能够擅长发现高维数据中的复杂结构，因此它能够被应用于科学、商业和政府等领域。除了在图像识别、语音识别等领域打破了纪录，它还在另外的领域击败了其他机器学习技术，包括预测潜在的药物分子的活性、分析粒子加速器数据、重建大脑回路、预测在非编码DNA突变对基因表达和疾病的影响。也许更令人惊讶的是，深度学习在自然语言理解的各项任务中产生了非常可喜的成果，特别是主题分类、情感分析、自动问答和语言翻译。我们认为，在不久的将来，深度学习将会取得更多的成功，因为它需要很少的手工工程，它可以很容易受益于可用计算能力和数据量的增加。目前正在为深度神经网络开发的新的学习算法和架构只会加速这一进程。</p><h1><span style="font-weight: normal;"><span style="font-size: 13px;">监督学习</span></span></h1><p>机器学习中，不论是否是深层，最常见的形式是监督学习。试想一下，我们要建立一个系统，它能够对一个包含了一座房子、一辆汽车、一个人或一个宠物的图像进行分类。我们先收集大量的房子，汽车，人与宠物的图像的数据集，并对每个对象标上它的类别。在训练期间，机器会获取一副图片，然后产生一个输出，这个输出以向量形式的分数来表示，每个类别都有一个这样的向量。我们希望所需的类别在所有的类别中具有最高的得分，但是这在训练之前是不太可能发生的。通过计算一个目标函数可以获得输出分数和期望模式分数之间的误差（或距离）。然后机器会修改其内部可调参数，以减少这种误差。这些可调节的参数，通常被称为权值，它们是一些实数，可以被看作是一些“旋钮”，定义了机器的输入输出功能。在典型的深学习系统中，有可能有数以百万计的样本和权值，和带有标签的样本，用来训练机器。为了正确地调整权值向量，该学习算法计算每个权值的梯度向量，表示了如果权值增加了一个很小的量，那么误差会增加或减少的量。权值向量然后在梯度矢量的相反方向上进行调整。我们的目标函数，所有训练样本的平均，可以被看作是一种在权值的高维空间上的多变地形。负的梯度矢量表示在该地形中下降方向最快，使其更接近于最小值，也就是平均输出误差低最低的地方。</p><p>在实际应用中，大部分从业者都使用一种称作随机梯度下降的算法（SGD）。它包含了提供一些输入向量样本，计算输出和误差，计算这些样本的平均梯度，然后相应的调整权值。通过提供小的样本集合来重复这个过程用以训练网络，直到目标函数停止增长。它被称为随机的是因为小的样本集对于全体样本的平均梯度来说会有噪声估计。这个简单过程通常会找到一组不错的权值，同其他精心设计的优化技术相比，它的速度让人惊奇。训练结束之后，系统会通过不同的数据样本——测试集来显示系统的性能。这用于测试机器的泛化能力——对于未训练过的新样本的识别能力。</p><p>当前应用中的许多机器学习技术使用的是线性分类器来对人工提取的特征进行分类。一个2类线性分类器会计算特征向量的加权和。当加权和超过一个阈值之后，输入样本就会被分配到一个特定的类别中。从20世纪60年代开始，我们就知道了线性分类器只能够把样本分成非常简单的区域，也就是说通过一个超平面把空间分成两部分。</p><p>但像图像和语音识别等问题，它们需要的输入-输出函数要对输入样本中不相关因素的变化不要过于的敏感，如位置的变化，目标的方向或光照，或者语音中音调或语调的变化等，但是需要对于一些特定的微小变化非常敏感（例如，一只白色的狼和跟狼类似的白色狗——萨莫耶德犬之间的差异）。在像素这一级别上，两条萨莫耶德犬在不同的姿势和在不同的环境下的图像可以说差异是非常大的，然而，一只萨摩耶德犬和一只狼在相同的位置并在相似背景下的两个图像可能就非常类似。</p><p style="text-align: center;"><img src="深入系列_files/Image [1].jpg" type="image/jpeg" style="float: none; margin: 0px;"/></p><p style="text-align: center;">图1 多层神经网络和BP算法</p><ol><li><span style="background-color: initial;">多层神经网络（用连接点表示）可以对输入空间进行整合，使得数据（红色和蓝色线表示的样本）线性可分。注意输入空间中的规则网格（左侧）是如何被隐藏层转换的（转换后的在右侧）。这个例子中只用了两个输入节点，两个隐藏节点和一个输出节点，但是用于目标识别或自然语言处理的网络通常包含数十个或者数百个这样的节点。获得C.Olah (</span><a href="http://colah.github.io/" style="background-color: initial;">http://colah.github.io/</a><span style="background-color: initial;">)的许可后重新构建的这个图。</span></li><li><span style="background-color: initial;">链式法则告诉我们两个小的变化（x和y的微小变化，以及y和z的微小变化）是怎样组织到一起的。x的微小变化量Δx首先会通过乘以∂y/∂x（偏导数）转变成y的变化量Δy。类似的，Δy会给z带来改变Δz。通过链式法则可以将一个方程转化到另外的一个——也就是Δx通过乘以∂y/∂x和∂z/∂y（英文原文为∂z/∂x，系笔误——编辑注）得到Δz的过程。当x，y，z是向量的时候，可以同样处理（使用雅克比矩阵）。</span></li><li><span style="background-color: initial;">具有两个隐层一个输出层的神经网络中计算前向传播的公式。每个都有一个模块构成，用于反向传播梯度。在每一层上，我们首先计算每个节点的总输入z，z是前一层输出的加权和。然后利用一个非线性函数f(.)来计算节点的输出。简单期间，我们忽略掉了阈值项。神经网络中常用的非线性函数包括了最近几年常用的校正线性单元（ReLU）f(z) = max(0,z)，和更多传统sigmoid函数，比如双曲线正切函数f(z) = (exp(z) − exp(−z))/(exp(z) + exp(−z)) 和logistic函数f(z) = 1/(1 + exp(−z))。</span></li><li><span style="background-color: initial;">计算反向传播的公式。在隐层，我们计算每个输出单元产生的误差，这是由上一层产生的误差的加权和。然后我们将输出层的误差通过乘以梯度f(z)转换到输入层。在输出层上，每个节点的误差会用成本函数的微分来计算。如果节点l的成本函数是0.5*(yl-tl)^2, 那么节点的误差就是yl-tl，其中tl是期望值。一旦知道了∂E/∂zk的值，节点j的内星权向量wjk就可以通过yj ∂E/∂zk来进行调整。</span></li></ol><p>一个线性分类器或者其他操作在原始像素上的浅层分类器不能够区分后两者，虽然能够将前者归为同一类。这就是为什么浅分类要求有良好的特征提取器用于解决选择性不变性困境——提取器会挑选出图像中能够区分目标的那些重要因素，但是这些因素对于分辨动物的位置就无能为力了。为了加强分类能力，可以使用泛化的非线性特性，如核方法，但这些泛化特征，比如通过高斯核得到的，并不能够使得学习器从学习样本中产生较好的泛化效果。传统的方法是手工设计良好的特征提取器，这需要大量的工程技术和专业领域知识。但是如果通过使用通用学习过程而得到良好的特征，那么这些都是可以避免的了。这就是深度学习的关键优势。</p><p>深度学习的体系结构是简单模块的多层栈，所有（或大部分）模块的目标是学习，还有许多计算非线性输入输出的映射。栈中的每个模块将其输入进行转换，以增加表达的可选择性和不变性。比如说，具有一个5到20层的非线性多层系统能够实现非常复杂的功能，比如输入数据对细节非常敏感——能够区分白狼和萨莫耶德犬，同时又具有强大的抗干扰能力，比如可以忽略掉不同的背景、姿势、光照和周围的物体等。</p><h1><span style="font-weight: normal;"><span style="font-size: 13px;">反向传播来训练多层神经网络</span></span></h1><p>在最早期的模式识别任务中，研究者的目标一直是使用可以训练的多层网络来替代经过人工选择的特征，虽然使用多层神经网络很简单，但是得出来的解很糟糕。直到20世纪80年代，使用简单的随机梯度下降来训练多层神经网络，这种糟糕的情况才有所改变。只要网络的输入和内部权值之间的函数相对平滑，使用梯度下降就凑效，梯度下降方法是在70年代到80年代期间由不同的研究团队独立发明的。 </p><p>用来求解目标函数关于多层神经网络权值梯度的反向传播算法（BP）只是一个用来求导的链式法则的具体应用而已。反向传播算法的核心思想是：目标函数对于某层输入的导数（或者梯度）可以通过向后传播对该层输出（或者下一层输入）的导数求得（如图1）。反向传播算法可以被重复的用于传播梯度通过多层神经网络的每一层：从该多层神经网络的最顶层的输出（也就是改网络产生预测的那一层）一直到该多层神经网络的最底层（也就是被接受外部输入的那一层），一旦这些关于（目标函数对）每层输入的导数求解完，我们就可以求解每一层上面的（目标函数对）权值的梯度了。</p><p>很多深度学习的应用都是使用前馈式神经网络（如图1），该神经网络学习一个从固定大小输入（比如输入是一张图）到固定大小输出（例如，到不同类别的概率）的映射。从第一层到下一层，计算前一层神经元输入数据的权值的和，然后把这个和传给一个非线性激活函数。当前最流行的非线性激活函数是rectified linear unit(ReLU)，函数形式：f(z)=max(z,0)。过去的几十年中，神经网络使用一些更加平滑的非线性函数，比如tanh(z)和1/(1+exp(-z))，但是ReLU通常会让一个多层神经网络学习的更快，也可以让一个深度网络直接有监督的训练（不需要无监督的pre-train）。</p><p>达到之前那种有pre-train的效果。通常情况下，输入层和输出层以外的神经单元被称为隐藏单元。隐藏层的作用可以看成是使用一个非线性的方式打乱输入数据，来让输入数据对应的类别在最后一层变得线性可分。</p><p>在20世纪90年代晚期，神经网络和反向传播算法被大多数机器学习团队抛弃，同时也不受计算机视觉和语音识别团队的重视。人们普遍认为，学习有用的、多级层次结构的、使用较少先验知识进行特征提取的这些方法都不靠谱。确切的说是因为简单的梯度下降会让整个优化陷入到不好的局部最小解。</p><p>实践中，如果在大的网络中，不管使用什么样的初始化条件，局部最小解并不算什么大问题，系统总是得到效果差不多的解。最近的理论和实验表明，局部最小解还真不是啥大问题。相反，解空间中充满了大量的鞍点（梯度为0的点），同时鞍点周围大部分曲面都是往上的。所以这些算法就算是陷入了这些局部最小值，关系也不太大。</p><p>2006年前后，CIFAR（加拿大高级研究院）把一些研究者聚集在一起，人们对深度前馈式神经网络重新燃起了兴趣。研究者们提出了一种非监督的学习方法，这种方法可以创建一些网络层来检测特征而不使用带标签的数据，这些网络层可以用来重构或者对特征检测器的活动进行建模。通过预训练过程，深度网络的权值可以被初始化为有意思的值。然后一个输出层被添加到该网络的顶部，并且使用标准的反向传播算法进行微调。这个工作对手写体数字的识别以及行人预测任务产生了显著的效果，尤其是带标签的数据非常少的时候。</p><p>使用这种与训练方法做出来的第一个比较大的应用是关于语音识别的，并且是在GPU上做的，这样做是因为写代码很方便，并且在训练的时候可以得到10倍或者20倍的加速。2009年，这种方法被用来映射短时间的系数窗口，该系统窗口是提取自声波并被转换成一组概率数字。它在一组使用很少词汇的标准的语音识别基准测试程序上达到了惊人的效果，然后又迅速被发展到另外一个更大的数据集上，同时也取得惊人的效果。从2009年到到2012年底，较大的语音团队开发了这种深度网络的多个版本并且已经被用到了安卓手机上。对于小的数据集来说，无监督的预训练可以防止过拟合，同时可以带来更好的泛化性能当有标签的样本很小的时候。一旦深度学习技术重新恢复，这种预训练只有在数据集合较少的时候才需要。</p></div><div><br/></div><div>然后，还有一种深度前馈式神经网络，这种网络更易于训练并且比那种全连接的神经网络的泛化性能更好。这就是卷积神经网络（CNN）。当人们对神经网络不感兴趣的时候，卷积神经网络在实践中却取得了很多成功，如今它被计算机视觉团队广泛使用。</div><div><br/></div><div><br/></div><div><h1><span style="font-weight: normal;"><span style="font-size: 13px;">卷积神经网络</span></span></h1><p><span style="background-color: initial;">卷积神经网络被设计用来处理到多维数组数据的，比如一个有3个包含了像素值2-D图像组合成的一个具有3个颜色通道的彩色图像。很多数据形态都是这种多维数组的：1D用来表示信号和序列包括语言，2D用来表示图像或者声音，3D用来表示视频或者有声音的图像。卷积神经网络使用4个关键的想法来利用自然信号的属性：局部连接、权值共享、池化以及多网络层的使用。</span></p><p style="text-align: center;"><img src="深入系列_files/Image [2].jpg" type="image/jpeg" style="float: none; margin: 0px;"/></p><p style="text-align: center;">图2 卷积神经网络内部</p><p>一个典型的卷积神经网络结构（如图2）是由一系列的过程组成的。最初的几个阶段是由卷积层和池化层组成，卷积层的单元被组织在特征图中，在特征图中，每一个单元通过一组叫做滤波器的权值被连接到上一层的特征图的一个局部块，然后这个局部加权和被传给一个非线性函数，比如ReLU。在一个特征图中的全部单元享用相同的过滤器，不同层的特征图使用不同的过滤器。使用这种结构处于两方面的原因。首先，在数组数据中，比如图像数据，一个值的附近的值经常是高度相关的，可以形成比较容易被探测到的有区分性的局部特征。其次，不同位置局部统计特征不太相关的，也就是说，在一个地方出现的某个特征，也可能出现在别的地方，所以不同位置的单元可以共享权值以及可以探测相同的样本。在数学上，这种由一个特征图执行的过滤操作是一个离线的卷积，卷积神经网络也是这么得名来的。</p><p>卷积层的作用是探测上一层特征的局部连接，然而池化层的作用是在语义上把相似的特征合并起来，这是因为形成一个主题的特征的相对位置不太一样。一般地，池化单元计算特征图中的一个局部块的最大值，相邻的池化单元通过移动一行或者一列来从小块上读取数据，因为这样做就减少的表达的维度以及对数据的平移不变性。两三个这种的卷积、非线性变换以及池化被串起来，后面再加上一个更多卷积和全连接层。在卷积神经网络上进行反向传播算法和在一般的深度网络上是一样的，可以让所有的在过滤器中的权值得到训练。</p><p>深度神经网络利用的很多自然信号是层级组成的属性，在这种属性中高级的特征是通过对低级特征的组合来实现的。在图像中，局部边缘的组合形成基本图案，这些图案形成物体的局部，然后再形成物体。这种层级结构也存在于语音数据以及文本数据中，如电话中的声音，因素，音节，文档中的单词和句子。当输入数据在前一层中的位置有变化的时候，池化操作让这些特征表示对这些变化具有鲁棒性。</p><p>卷积神经网络中的卷积和池化层灵感直接来源于视觉神经科学中的简单细胞和复杂细胞。这种细胞的是以LNG-V1-V2-V4-IT这种层级结构形成视觉回路的。当给一个卷积神经网络和猴子一副相同的图片的时候，卷积神经网络展示了猴子下颞叶皮质中随机160个神经元的变化。卷积神经网络有神经认知的根源，他们的架构有点相似，但是在神经认知中是没有类似反向传播算法这种端到端的监督学习算法的。一个比较原始的1D卷积神经网络被称为时延神经网络，可以被用来识别语音以及简单的单词。</p><p>20世纪90年代以来，基于卷积神经网络出现了大量的应用。最开始是用时延神经网络来做语音识别以及文档阅读。这个文档阅读系统使用一个被训练好的卷积神经网络和一个概率模型，这个概率模型实现了语言方面的一些约束。20世纪90年代末，这个系统被用来美国超过10%的支票阅读上。后来，微软开发了基于卷积神经网络的字符识别系统以及手写体识别系统。20世纪90年代早期，卷积神经网络也被用来自然图形中的物体识别，比如脸、手以及人脸识别（<span style="background-color: initial;">face recognition </span><span style="background-color: initial;">）。</span></p><h1><span style="font-weight: normal;"><span style="font-size: 13px;">使用深度卷积网络进行图像理解</span></span></h1><p>21世纪开始，卷积神经网络就被成功的大量用于检测、分割、物体识别以及图像的各个领域。这些应用都是使用了大量的有标签的数据，比如交通信号识别，生物信息分割，面部探测，文本、行人以及自然图形中的人的身体部分的探测。近年来，卷积神经网络的一个重大成功应用是人脸识别。</p><p>值得一提的是，图像可以在像素级别进行打标签，这样就可以应用在比如自动电话接听机器人、自动驾驶汽车等技术中。像Mobileye以及NVIDIA公司正在把基于卷积神经网络的方法用于汽车中的视觉系统中。其它的应用涉及到自然语言的理解以及语音识别中。</p><p style="text-align: center;"><img src="深入系列_files/Image [3].jpg" type="image/jpeg" style="float: none; margin: 0px;"/></p><p style="text-align: center;">图3 从图像到文字</p><p>尽管卷积神经网络应用的很成功，但是它被计算机视觉以及机器学习团队开始重视是在2012年的ImageNet竞赛。在该竞赛中，深度卷积神经网络被用在上百万张网络图片数据集，这个数据集包含了1000个不同的类。该结果达到了前所未有的好，几乎比当时最好的方法降低了一半的错误率。这个成功来自有效地利用了GPU、ReLU、一个新的被称为dropout的正则技术，以及通过分解现有样本产生更多训练样本的技术。这个成功给计算机视觉带来一个革命。如今，卷积神经网络用于几乎全部的识别和探测任务中。最近一个更好的成果是，利用卷积神经网络结合回馈神经网络用来产生图像标题。</p><p>如今的卷积神经网络架构有10-20层采用ReLU激活函数、上百万个权值以及几十亿个连接。然而训练如此大的网络两年前就只需要几周了，现在硬件、软件以及算法并行的进步，又把训练时间压缩到了几小时。</p><p>基于卷积神经网络的视觉系统的性能已经引起了大型技术公司的注意，比如Google、Facebook、Microsoft、IBM，yahoo！、Twitter和Adobe等，一些快速增长的创业公司也同样如是。</p><p>卷积神经网络很容易在芯片或者现场可编程门阵列（FPGA）中高效实现，许多公司比如NVIDIA、Mobileye、Intel、Qualcomm以及Samsung，正在开发卷积神经网络芯片，以使智能机、相机、机器人以及自动驾驶汽车中的实时视觉系统成为可能。</p><h1><span style="font-weight: normal;"><span style="font-size: 13px;">分布式特征表示与语言处理</span></span></h1><p>与不使用分布式特征表示（<span style="background-color: initial;">distributed representations </span><span style="background-color: initial;">）</span><span style="background-color: initial;">的经典学习算法相比，深度学习理论表明深度网络具有两个不同的巨大的优势。这些优势来源于网络中各节点的权值，并取决于具有合理结构的底层生成数据的分布。首先，学习</span><span>分布式特征表示</span><span style="background-color: initial;">能够泛化适应新学习到的特征值的组合（比如，n元特征就有2</span><span style="font-size: 13px;"><sup style="background-color: initial;">n</sup><span style="background-color: initial;">种可能的组合）。其次，深度网络中组合表示层带来了另一个指数级的优势潜能（指数级的深度）。</span></span></p><p>多层神经网络中的隐层利用网络中输入的数据进行特征学习，使之更加容易预测目标输出。下面是一个很好的示范例子，比如将本地文本的内容作为输入，训练多层神经网络来预测句子中下一个单词。内容中的每个单词表示为网络中的N分之一的向量，也就是说，每个组成部分中有一个值为1其余的全为0。在第一层中，每个单词创建不同的激活状态，或单词向量（如图4）。在语言模型中，网络中其余层学习并转化输入的单词向量为输出单词向量来预测句子中下一个单词，可以通过预测词汇表中的单词作为文本句子中下一个单词出现的概率。网络学习了包含许多激活节点的、并且可以解释为词的独立特征的单词向量，正如第一次示范的文本学习分层表征文字符号的例子。这些语义特征在输入中并没有明确的表征。而是在利用“微规则”（‘micro-rules’,本文中直译为：微规则）学习过程中被发掘，并作为一个分解输入与输出符号之间关系结构的好的方式。当句子是来自大量的真实文本并且个别的微规则不可靠的情况下，学习单词向量也一样能表现得很好。利用训练好的模型预测新的事例时，一些概念比较相似的词容易混淆，比如星期二（Tuesday）和星期三（Wednesday），瑞典（Sweden）和挪威（Norway）。这样的表示方式被称为分布式特征表示，因为他们的元素之间并不互相排斥，并且他们的构造信息对应于观测到的数据的变化。这些单词向量是通过学习得到的特征构造的，这些特征不是由专家决定的，而是由神经网络自动发掘的。从文本中学习得单词向量表示现在广泛应用于自然语言中。</p><p style="text-align: center;"><img src="深入系列_files/Image [4].jpg" type="image/jpeg" style="float: none; margin: 0px;"/></p><p style="text-align: center;"><img src="深入系列_files/Image [5].jpg" type="image/jpeg" style="float: none; margin: 0px;"/></p><p style="text-align: center;">图4 词向量学习可视化</p><p>特征表示问题争论的中心介于对基于逻辑启发和基于神经网络的认识。在逻辑启发的范式中，一个符号实体表示某一事物，因为其唯一的属性与其他符号实体相同或者不同。该符号实例没有内部结构，并且结构与使用是相关的，至于理解符号的语义，就必须与变化的推理规则合理对应。相反地，神经网络利用了大量活动载体、权值矩阵和标量非线性化，来实现能够支撑简单容易的、具有常识推理的快速“直觉”功能。</p><p>在介绍神经语言模型前，简述下标准方法，其是基于统计的语言模型，该模型没有使用分布式特征表示。而是基于统计简短符号序列出现的频率增长到N（N-grams，N元文法）。可能的N-grams的数字接近于V<span style="font-size: 13px;"><sup>N</sup>，其中V是词汇表的大小，考虑到文本内容包含成千上万个单词，所以需要一个非常大的语料库。N-grams将每个单词看成一个原子单元，因此不能在语义相关的单词序列中一概而论，然而神经网络语言模型可以，是因为他们关联每个词与真是特征值的向量，并且在向量空间中语义相关的词彼此靠近（图4）。</span></p><h1><span style="font-weight: normal;"><span style="font-size: 13px;">递归神经网络</span></span></h1><p>首次引入反向传播算法时，最令人兴奋的便是使用递归神经网络（recurrent neural networks，下文简称RNNs）训练。对于涉及到序列输入的任务，比如语音和语言，利用RNNs能获得更好的效果。RNNs一次处理一个输入序列元素，同时维护网络中隐式单元中隐式的包含过去时刻序列元素的历史信息的“状态向量”。如果是深度多层网络不同神经元的输出，我们就会考虑这种在不同离散时间步长的隐式单元的输出，这将会使我们更加清晰怎么利用反向传播来训练RNNs（如图5，右）。</p><p style="text-align: center;"><img src="深入系列_files/Image [6].jpg" type="image/jpeg" style="float: none; margin: 0px;"/></p><p style="text-align: center;">图5 递归神经网络</p><p>RNNs是非常强大的动态系统，但是训练它们被证实存在问题的，因为反向传播的梯度在每个时间间隔内是增长或下降的，所以经过一段时间后将导致结果的激增或者降为零。</p><p>由于先进的架构和训练方式，RNNs被发现可以很好的预测文本中下一个字符或者句子中下一个单词，并且可以应用于更加复杂的任务。例如在某时刻阅读英语句子中的单词后，将会训练一个英语的“编码器”网络，使得隐式单元的最终状态向量能够很好地表征句子所要表达的意思或思想。这种“思想向量”（thought vector）可以作为联合训练一个法语“编码器”网络的初始化隐式状态（或者额外的输入），其输出为法语翻译首单词的概率分布。如果从分布中选择一个特殊的首单词作为编码网络的输入，将会输出翻译的句子中第二个单词的概率分布，并直到停止选择为止。总体而言，这一过程是根据英语句子的概率分布而产生的法语词汇序列。这种简单的机器翻译方法的表现甚至可以和最先进的（state-of-the-art）的方法相媲美，同时也引起了人们对于理解句子是否需要像使用推理规则操作内部符号表示质疑。这与日常推理中同时涉及到根据合理结论类推的观点是匹配的。</p><p>类比于将法语句子的意思翻译成英语句子，同样可以学习将图片内容“翻译”为英语句子（如图3）。这种编码器是可以在最后的隐层将像素转换为活动向量的深度卷积网络（ConvNet）。解码器与RNNs用于机器翻译和神经网络语言模型的类似。近来，已经掀起了一股深度学习的巨大兴趣热潮（参见文献[86]提到的例子）。</p><p>RNNs一旦展开（如图5），可以将之视为一个所有层共享同样权值的深度前馈神经网络。虽然它们的目的是学习长期的依赖性，但理论的和经验的证据表明很难学习并长期保存信息。</p><p>为了解决这个问题，一个增大网络存储的想法随之产生。采用了特殊隐式单元的LSTM（long short-termmemory networks）被首先提出，其自然行为便是长期的保存输入。一种称作记忆细胞的特殊单元类似累加器和门控神经元：它在下一个时间步长将拥有一个权值并联接到自身，拷贝自身状态的真实值和累积的外部信号，但这种自联接是由另一个单元学习并决定何时清除记忆内容的乘法门控制的。</p><p>LSTM网络随后被证明比传统的RNNs更加有效，尤其当每一个时间步长内有若干层时，整个语音识别系统能够完全一致的将声学转录为字符序列。目前LSTM网络或者相关的门控单元同样用于编码和解码网络，并且在机器翻译中表现良好。</p><p>过去几年中，几位学者提出了不同的提案用于增强RNNs的记忆模块。提案中包括神经图灵机，其中通过加入RNNs可读可写的“类似磁带”的存储来增强网络，而记忆网络中的常规网络通过联想记忆来增强。记忆网络在标准的问答基准测试中表现良好，记忆是用来记住稍后要求回答问题的事例。</p><p>除了简单的记忆化，神经图灵机和记忆网络正在被用于那些通常需要推理和符号操作的任务，还可以教神经图灵机“算法”。除此以外，他们可以从未排序的输入符号序列（其中每个符号都有与其在列表中对应的表明优先级的真实值）中，学习输出一个排序的符号序列。可以训练记忆网络用来追踪一个设定与文字冒险游戏和故事的世界的状态，回答一些需要复杂推理的问题。在一个测试例子中，网络能够正确回答15句版的《指环王》中诸如“Frodo现在在哪？”的问题。</p><h1><span style="font-weight: normal;"><span style="font-size: 13px;">深度学习的未来展望</span></span></h1><p>无监督学习对于重新点燃深度学习的热潮起到了促进的作用，但是纯粹的有监督学习的成功盖过了无监督学习。在本篇综述中虽然这不是我们的重点，我们还是期望无监督学习在长期内越来越重要。无监督学习在人类和动物的学习中占据主导地位：我们通过观察能够发现世界的内在结构，而不是被告知每一个客观事物的名称。</p><p>人类视觉是一个智能的、基于特定方式的利用小或大分辨率的视网膜中央窝与周围环绕区域对光线采集成像的活跃的过程。我们期望未来在机器视觉方面会有更多的进步，这些进步来自那些端对端的训练系统，并结合ConvNets和RNNs，采用增强学习<span style="background-color: initial;">来决定走向。结合了深度学习和增强学习的系统正处在初期，但已经在分类任务中超过了被动视频系统，并在学习操作视频游戏中产生了令人印象深刻的效果。</span></p><p>在未来几年，自然语言理解将是深度学习做出巨大影响的另一个领域。我们预测那些利用了RNNs的系统将会更好地理解句子或者整个文档，当它们选择性地学习了某时刻部分加入的策略。</p></div><div><br/></div><div>最终，在人工智能方面取得的重大进步将来自那些结合了复杂推理表示学习（representation learning ）的系统。尽管深度学习和简单推理已经应用于语音和手写字识别很长一段时间了，我们仍需要通过操作大量向量的新范式来代替基于规则的字符表达式操作。</div></span>
</div>
<hr>
<a name="742"/>

<div>
<span><div>《构建嵌入式linux系统》 KARIM YAGHMOUR著 中国电力出版社</div><div><br/></div><div><div style="TEXT-INDENT: 2em;"><div><br/></div><div>本书背景知识：</div></div><p style="TEXT-INDENT: 2em;">Linux系统管理、Linux设备驱动程序、Linux内核的运行原理、GNU软件开发工具</p><p style="TEXT-INDENT: 2em;">总体感觉：</p><p style="TEXT-INDENT: 2em;">有点像本手册，思路不顺畅的时候可以查查，书中内容涉及甚广，提供的外部信息</p><p style="TEXT-INDENT: 2em;">较多，但部分链接已经不能使用。</p><p style="TEXT-INDENT: 2em;"> </p><p style="TEXT-INDENT: 2em;">一、建立目标板Linux系统的四个重要步骤：</p><p style="TEXT-INDENT: 2em;">1、决定系统组建：静思自己的需求，列出清单，</p><p style="TEXT-INDENT: 2em;">建议：鉴于最新软件与其它各个软件包依存性，要慎重考虑在设计中使用最新最优秀的软件。</p><p style="TEXT-INDENT: 2em;">2、配置及建立内核</p><p style="TEXT-INDENT: 2em;">建议：关注内核发展，判断更新内核是否对你最好，较旧内核的社群支持不够。</p><p style="TEXT-INDENT: 2em;">3、建立根文件系统</p><p style="TEXT-INDENT: 2em;">嵌入式linux系统的根文件系统与运行linux的工作站或服务器类似，不过嵌入式linux系统只包含系统运行所必需的应用程序、链接库和相关文件的最小集合，文件系统大小应该以系统需求分析估值为目标。</p><p style="TEXT-INDENT: 2em;">4、设置引导软件与配置</p><p style="TEXT-INDENT: 2em;"> </p><p style="TEXT-INDENT: 2em;">二、开发嵌入式Linux系统有三种不同的主/目标板架构：</p><p style="TEXT-INDENT: 2em;">连接式设置：最常用，Ethernet连接用来下载可执行文件，RS232用来调试</p><p style="TEXT-INDENT: 2em;">可抽换存储装置设置：先主机将数据写入存储，然后该存储转接目标机</p><p style="TEXT-INDENT: 2em;">独立式设置：不需要任何跨平台的开发环境。</p><p style="TEXT-INDENT: 2em;">硬件调试：BDM或JTAG。</p><p style="TEXT-INDENT: 2em;"> </p><p style="TEXT-INDENT: 2em;">三、存储器配置图的重要性</p><p style="TEXT-INDENT: 2em;">在进行软件开发之前，应该先花些时间建立好系统的物理存储器配置图，因为物理存储器可以提供如何设定内核配置及如何开发定制驱动程序开发的信息。</p><p style="TEXT-INDENT: 2em;">与物理存储器配置图相比，虚拟存储器配置图的安排是内核配置设定或设备驱动开发的第二个重点，它可以帮助我们了解和调试应用程序。可以查看《lld》进一步深入。</p><p style="TEXT-INDENT: 2em;"> </p><p style="TEXT-INDENT: 2em;">四、总线相关</p><p style="TEXT-INDENT: 2em;">Industry Standard Architecture(工业标准架构，ISA)总线是PC-AT架构的核心。ISA的架构简单，存取ISA设备主要通过对I/O端口进行编程实现，《ISA System Archtecture》则对ISA总线及相关硬件提供了深入说明。</p><p style="TEXT-INDENT: 2em;">PCI Special Interest Group(PCI专责小组，PCI-SIG)制定的Peripheral Component Interconnect（外围组建互连，PCI）是目前最普遍的总线，被设计用来代替ISA。与ISA不同的是，设备驱动程序必需提供软件的支持才能使用PCI，此项支持的第一个部分包括，在引导期间初始化并配置PCI设备，在PC系统上，这项工作传统上由BIOS来完成。《PCI System Archtecture》提供了PCI总线的详细信息。</p><p style="TEXT-INDENT: 2em;">Personal Computer Memory Card International Association（国际个人计算机存储卡协会，PCMCIA）既是一个总线的通称，也是一个组织。linux PCMCIA计划在SourceForge网站上，网址为：<a href="http://pcmcia-cs.sourceforge.net/" rel="nofollow">http://pcmcia-cs.sourceforge.net</a>,《linux PCMCIA Programmer’s Guide》可以继续深入。</p><p style="TEXT-INDENT: 2em;">CompactPCI规格创始于Ziatech，并由PCI Industrial Computer Manufacturer’s Group继续延伸发展，CompactPCI成功之处主要是它基于设计者选择的技术，首先，使用了因VME而普及的Eurocard结构，其次，与PCI总线兼容。同时，CompactPCI允许热拔插规范（三个等级）：</p><p style="TEXT-INDENT: 2em;">基本热拔插：新卡片插入时，要求系统操作员通知操作系统</p><p style="TEXT-INDENT: 2em;">完整热拔插：系统操作员拨动卡片上的微动开关来通知操作系统该卡片将被移除</p><p style="TEXT-INDENT: 2em;">高可用：卡片完全受软件控制</p><p style="TEXT-INDENT: 2em;">Small Computer Systems Interface（小型计算机系统接口，SCSI）用来连接各种外围硬件的通用接口，只有少数高端嵌入式系统会使用SCSI设备。关于SCSI设备驱动程序架构的探讨，可以在<a href="http://www.torque.net/sg/" rel="nofollow">http://www.torque.net/sg/</a>和<a href="http://www.andante.org/scsi.html%E4%BB%A5%E5%8F%8ALDP" rel="nofollow">http://www.andante.org/scsi.html以及LDP</a>的《The Linux 2.5 SCSI subsystem HOWTO》文档中找到。SCSI的程序设计可以参考《The Linux SCSI Programming HOWTO》和《LDD》。</p><p style="TEXT-INDENT: 2em;">Universal Serial Bus（通用串行总线，USB）的目的在于取代并口和串口之类不完整和慢速的接口，推荐站点：<a href="http://www.linux-usb.org/" rel="nofollow">http://www.linux-usb.org/</a>，推荐USB设备开发的书：《Programming Guide for Linux USB Device Drivers》《LDD》.</p><p style="TEXT-INDENT: 2em;">IEEE1394(Firewire，火线)是Apple的技术标准，适合大量数据传送，比USB性能优越，IEEE1394可以直接连接两部或多部计算机，甚至可以在IP上实现IEEE1394（将编程嵌入式linux调试非常有利的手段），USB没法做到，《FireWire System Architecture》继续深入</p><p style="TEXT-INDENT: 2em;">Inter-Integrated Circuit（集成电路间，I2C）是个简单的小型串行总线，具有I2C能力的设备：LCD驱动器、EEPROM、DSP.,etc，该总线可以用软或硬件的方法实现，使用I2C总线连接设备时，只需两条信号线：串行时钟线、串行数据线。<a href="http://www2.lm-sensor.nul/%7Elm78/" rel="nofollow">http://www2.lm-sensor.nul/~lm78/</a>包含一份所支持的I2C设备清单，已经每个设备使用的驱动程序。</p><p style="TEXT-INDENT: 2em;"> </p><p style="TEXT-INDENT: 2em;">五、计算机I/O</p><p style="TEXT-INDENT: 2em;">RS232串口是硬件接口，所以内核不需要支持RS232本身。内核包含RS232通信芯片（Universal Asynchronous Receiver-Transmitter，通用异步收发器，UART）驱动，UART驱动位于drivers/char/serial.c ，”Serial HOWTO”找到串口的基础知识，可以在”Serial Programming HOWTO”找到串口程序设计的方法。推荐《unix环境高级编程》，调制解调器在linux中会被当作串口。</p><p style="TEXT-INDENT: 2em;">并口在嵌入式系统中用的很少，只有多位I/O（用来调试）利用并口和LED灯进行程序执行位置定位时候用到（这个技巧在程序代码中的各个位置上插入一组并口的输出命令）。</p><p style="TEXT-INDENT: 2em;">Comedi是linux连接DAQ（数据采集模块，linux中不存在任何标准接口来连接该模块）硬件的主要套件，可以在<a href="http://www.comedi.org/" rel="nofollow">http://www.comedi.org/</a>中找到该套件，其中包含大量DAQ板设备驱动程序</p><p style="TEXT-INDENT: 2em;">过程控制最常用的方法是使用PLC，讲linux用于控制的方法很多，可以用串口或并口来驱动外部硬件，如步进马达，《LDD》中有所讲述。</p><p style="TEXT-INDENT: 2em;">MisterHouse是一个完整的家庭自动化解决方案，PC系统中，键盘输入依次经过以下（drivers/char目录下）程序文件处理：pc_keyb.c、keyboard.c和tty_io.c（终端I/O驱动程序），以USB为例，其输入的处理过程如下：usb/usbkbd.c、input/keybdev.c、char/keyboard.c、char/tty_io.c</p><p style="TEXT-INDENT: 2em;">音效设备Linux中主要的音效设备通常是/dev/dsp，其他如/dev/mixer和/dev/sequencer同样具备其他音效的能力。ALSA的主要目标是提供一个完全模块化的声卡驱动程序套件，可以在<a href="http://www.alsa-project.org/" rel="nofollow">http://www.alsa-project.org/</a>上找到相关的文件和源码。</p><p style="TEXT-INDENT: 2em;"> </p><p style="TEXT-INDENT: 2em;">六、MTD/网卡驱动/802.11/Bluetooth</p><p style="TEXT-INDENT: 2em;">memory technology device（存储设备技术，MTD）</p><p style="TEXT-INDENT: 2em;">在linux术语中，memory technology device（存储设备技术，MTD）涵盖了所有存储设备，Linux内核纳入了MTD子系统，它提供了一致统一的接口，让底层的MTD芯片驱动程序无缝地与称为“用户模块”的较高层接口组合在一起，MTD芯片驱动程序必需通过mtd_info结构给add_mtd_device()函数提供一组缺省的回调函数及属性，向MTD子系统注册。下面列出目前已有的MTD芯片驱动程序：DOC/CFI/JEDEC/非DOC的NAND flash/旧式非CFI的flash/RAM/ROM/虚拟设备。 MTD子系统提供两种可用来模拟实际MTD硬件和MTD驱动程序：其中一个驱动程序模拟MTD设备的方式是使用虚拟寻址空间提供的内存，另一个驱动程序模拟MTD设备的方式是使用一般的块设备。可以在<a href="http://www.linux-mtd.infradead.org/" rel="nofollow">http://www.linux-mtd.infradead.org/</a>的网站上找到与实现MTD用户模块及MTD芯片驱动程序的API有关的文档。推荐《programming embedded systems in c and c++》</p><p style="TEXT-INDENT: 2em;">Ethernet驱动程序的Donald Becker在<a href="http://www.scyld.com/network/" rel="nofollow">http://www.scyld.com/network/</a>维护了一个网站，目的在于提供与Linux的网络驱动程序有关的信息。</p><p style="TEXT-INDENT: 2em;">802.11标准支持计算机以2.4GHz（802.11b）和5GHz（802.11a）的频率进行无线通信，要了解Linux支持哪些802.11硬件以及相关的驱动程序和工具，建议参考《Linux Wireless LAN HOWTO》，可以在<a href="http://www.hpl.hp.com/personal/Jean_Tourrilhes/" rel="nofollow">http://www.hpl.hp.com/personal/Jean_Tourrilhes/</a> 上找到该文件。《802.11 Wireless Networks:The Definitive Guide》对802.11技术及Linux如何使用802.11设备有完整的讨论。</p><p style="TEXT-INDENT: 2em;">Bluetooth运行在2.4GHz的频带上，并且使用扩频挑频技术，Linux具有若干Bluetooth堆栈，主要的堆栈有四个：BlueZ（主流，可从<a href="http://bluez.sourceforge.net/" rel="nofollow">http://bluez.sourceforge.net/</a> 上获得）、OpenBT（源码注释和文档比bluez好，可从<a href="http://developer.axis.com/software/bluetooth/" rel="nofollow">http://developer.axis.com/software/bluetooth/</a> 上获得）、Affix（<a href="http://affix.sourceforge.net/" rel="nofollow">http://affix.sourceforge.net/</a> ，被构建成一个网络协议）和BlueDrekar(<a href="http://www.alphaworks.ibm.com/tech/bluedrekar/" rel="nofollow">http://www.alphaworks.ibm.com/tech/bluedrekar/</a> 上获得)。</p><p style="TEXT-INDENT: 2em;">驱动开发站点推荐：<a href="http://www.arm.linux.org/" rel="nofollow">http://www.arm.linux.org</a></p><p style="TEXT-INDENT: 2em;"> </p><p style="TEXT-INDENT: 2em;">七、嵌入式项目目录安排建议：</p><p style="TEXT-INDENT: 2em;">bootldr 目标板的引导加载程序</p><p style="TEXT-INDENT: 2em;">build-tools 建立跨平台开发工具链需要用到的包和目录</p><p style="TEXT-INDENT: 2em;">debug 调试工具以及所有相关包</p><p style="TEXT-INDENT: 2em;">doc 项目将会用到的所有文档</p><p style="TEXT-INDENT: 2em;">images 准备使用在目标板上的引导加载程序和内核二进制映像，以及根文件系统</p><p style="TEXT-INDENT: 2em;">kernel 将在目标板上进行评估的各个内核版本</p><p style="TEXT-INDENT: 2em;">rootfs 目标板的内核在运行时看到的根文件系统</p><p style="TEXT-INDENT: 2em;">sysapps 目标板需要用到的系统应用程序</p><p style="TEXT-INDENT: 2em;">tmp 临时目录</p><p style="TEXT-INDENT: 2em;">tools 跨平台开发工具链以及C链接库目录:ld、gas、ar、gcc、C链接库（glibc）</p><p style="TEXT-INDENT: 2em;"> </p><p style="TEXT-INDENT: 2em;">八、交叉编译环境</p><p style="TEXT-INDENT: 2em;">交叉编译环境建立可以参考《Guede to ARMLinux for Developers》（<a href="http://www.alephl.co.uk/armlinux/book/book1.html" rel="nofollow">http://www.alephl.co.uk/armlinux/book/book1.html</a> ）</p><p style="TEXT-INDENT: 2em;">CrossGCC FAQ可以从<a href="http://corssgcc.billgatliff.com/" rel="nofollow">http://corssgcc.billgatliff.com/</a> 获得</p><p style="TEXT-INDENT: 2em;">交叉编译环境建立有疑难杂症可以去<a href="http://sources.redhat.com/ml/corssgcc/" rel="nofollow">http://sources.redhat.com/ml/corssgcc/</a> 上去看看</p><p style="TEXT-INDENT: 2em;">交叉编译建立步骤：</p><p style="TEXT-INDENT: 2em;">1、  内核头文件设置 ：make ARCH=arm CROSS_COMPILE=arm-linux- menuconfig</p><p style="TEXT-INDENT: 2em;">2、  binutils(汇编器as和链接器ld)的设置：../binutils-2.10.1/configure –target=$TARGET \ –prefix=$(PREFIX)</p><p style="TEXT-INDENT: 2em;">3、  引导编译器设置:../gcc-2.95.3/configure –target=$TARGET –prefix=$(PREFIX) \ –without-headers –with-newlib –anable-languages=c</p><p style="TEXT-INDENT: 2em;">4、  glibc设置:CC=arm-linxu-gcc ../glibc-2.2.3/configure –host=$TARGET \ –with-headers=$(TARGET_PREFIX) /include</p><p style="TEXT-INDENT: 2em;">5、  完整编译器的设置:../gcc-2.95.3/configure –target=$TARGET –prefix=$(FREFIX ) \ –enable-languages=c,c++</p><p style="TEXT-INDENT: 2em;">6、  完成工具链的设置 :修改path路径</p><p style="TEXT-INDENT: 2em;">7、  使用工具链</p><p style="TEXT-INDENT: 2em;">注意：用uclibc（<a href="http://uclibc.org/" rel="nofollow">http://uclibc.org/</a> ,发源并独立于uClinux计划）代替glibc</p><p style="TEXT-INDENT: 2em;">配置：make CROSS=arm-linux menuconfig</p><p style="TEXT-INDENT: 2em;">编译：make CROSS=arm-linux-</p><p style="TEXT-INDENT: 2em;">安装：make CROSS=arm-linux- PREFIX=”” install</p><p style="TEXT-INDENT: 2em;"> </p><p style="TEXT-INDENT: 2em;">九、语言相关</p><p style="TEXT-INDENT: 2em;">Python常被用在和perl相同的用途上，推荐书籍：&lt;Programming Python&gt; &lt;Learning Python&gt;<a href="http://www.python.org/" rel="nofollow">http://www.python.org/</a> 上获得python解释器和安装库，主要的python不支持交叉编译，可以下载补丁（<a href="http://www.ailis.de/%7Ek/patches/python-cross-compile.diff" rel="nofollow">http://www.ailis.de/~k/patches/python-cross-compile.diff</a> ）实现目标板上执行python程序。Python cross-compiling HOWTO 可以从<a href="http://www.ailis.de/%7Ek/knowledge/crosscompiling/python.php" rel="nofollow">http://www.ailis.de/~k/knowledge/crosscompiling/python.php</a> 获得</p><p style="TEXT-INDENT: 2em;">集成开发环境：</p><p style="TEXT-INDENT: 2em;">IDE              位置                  所支持语言</p><p style="TEXT-INDENT: 2em;">Anjuta  <a href="http://anjuta.sourceforge.net/" rel="nofollow">http://anjuta.sourceforge.net/</a>    Ada、bash、C、C++、Java、make、Perl、Python</p><p style="TEXT-INDENT: 2em;">Eclipse  <a href="http://www.eclipse.org/" rel="nofollow">http://www.eclipse.org/</a>        C、C++、Java</p><p style="TEXT-INDENT: 2em;">Glimmer <a href="http://glimmer.sourceforge.org/" rel="nofollow">http://glimmer.sourceforge.org/</a>  Ada、bash、C、C++、Java、make、Perl、Python、x86 assembly</p><p style="TEXT-INDENT: 2em;">Kdevelop   <a href="http://www.kdevelp.org/" rel="nofollow">http://www.kdevelp.org/</a>       C、C++、Java ,可以对其进行交叉开发定制</p><p style="TEXT-INDENT: 2em;">SourceNavigator <a href="http://www.sources.redhat.com/sourcenav/" rel="nofollow">http://www.sources.redhat.com/sourcenav/</a>  C、C++、Java、python</p><p style="TEXT-INDENT: 2em;">Linux常用的终端仿真程序：</p><p style="TEXT-INDENT: 2em;">minicom</p><p style="TEXT-INDENT: 2em;">cu ：UNIX系统常用方法</p><p style="TEXT-INDENT: 2em;">Kermit ：可从<a href="http://www.columbia.edu/kermit/ckermit.html" rel="nofollow">http://www.columbia.edu/kermit/ckermit.html</a> 下载，推荐《Using C-Kermit》</p><p style="TEXT-INDENT: 2em;">内核方面的考虑：</p><p style="TEXT-INDENT: 2em;">每种处理器最适合的内核供应网站：</p><p style="TEXT-INDENT: 2em;">x86      <a href="http://www.kernel.org/" rel="nofollow">http://www.kernel.org/</a></p><p style="TEXT-INDENT: 2em;">ARM    <a href="http://www.arm.linux.org.uk/developer/" rel="nofollow">http://www.arm.linux.org.uk/developer/</a> 可从x86处下载普通内核，此处下载补丁</p><p style="TEXT-INDENT: 2em;">PowPC   <a href="http://penguinppc.org/" rel="nofollow">http://penguinppc.org/</a></p><p style="TEXT-INDENT: 2em;">MIPS      <a href="http://www.linux-mips.org/" rel="nofollow">http://www.linux-mips.org/</a></p><p style="TEXT-INDENT: 2em;">SuperH   <a href="http://linuxsh.sourceforge.net/" rel="nofollow">http://linuxsh.sourceforge.net/</a></p><p style="TEXT-INDENT: 2em;">M68k    <a href="http://www.linux-m68k.org/" rel="nofollow">http://www.linux-m68k.org/</a></p><p style="TEXT-INDENT: 2em;">至少一周探访一次移植版本的网站及阅读《kernel Traffic》（<a href="http://ww.kerneltraffic.org/" rel="nofollow">http://ww.kerneltraffic.org/</a> ）</p><p style="TEXT-INDENT: 2em;">若想了解如何对内核进行修补，可参考《Running Linux》</p><p style="TEXT-INDENT: 2em;">区分同一个内核版本的各个变体可以修改内核主目录里头的makefile文件，讲EXTRAVERSION变量设置成自己想要的值。</p><p style="TEXT-INDENT: 2em;"> </p><p style="TEXT-INDENT: 2em;">十、编译内核三部曲：</p><p style="TEXT-INDENT: 2em;">建立内核源码的依存(生成隐藏的.depend文件)关系 ：</p><p style="TEXT-INDENT: 2em;">make ARCH=arm CROSS_COMPILE=arm-linux- clean dep</p><p style="TEXT-INDENT: 2em;">建立内核映像(&lt;512k,bzImage无限制，但都采用gzip算法)：</p><p style="TEXT-INDENT: 2em;">make ARCH=arm CROSS_COMPILE=arm-linux- zImage</p><p style="TEXT-INDENT: 2em;">建立内核模块：</p><p style="TEXT-INDENT: 2em;">                                                 make ARCH=arm CROSS_COMPILE=arm-linux- modules</p><p style="TEXT-INDENT: 2em;">清理内核源码：</p><p style="TEXT-INDENT: 2em;">                                                 make ARCH=arm CROSS_COMPILE=arm-linux- distclean</p><p style="TEXT-INDENT: 2em;"> </p><p style="TEXT-INDENT: 2em;">安装内核模块：make ARCH=arm CROSS_COMPILE=arm-linux- INSTALL_MOD_PATH= \</p><p style="TEXT-INDENT: 2em;">              $(PRJROOT)/images/modules-2.4.18-rmk5  modules_install</p><p style="TEXT-INDENT: 2em;">试着利用depmod（非用来处理交叉编译的模块）来建立依存关系会失败，要成功必须用到BusyBox提供的模块依存关系建立程序，可在<a href="http://www.busybox.net/" rel="nofollow">http://www.busybox.net/</a> 下载busybox，并把busybox的scripts/depmod.pl命令脚本复制到$(PREFIX)/bin目录中，现在可以为目标板建立依存模块依存关系：depmod.pl \</p><p style="TEXT-INDENT: 2em;">                  -k ./vmlinux –F ./System.map\</p><p style="TEXT-INDENT: 2em;">                  -b $(PRJROOT)/images/modules-2.4.18-rmk5/lib/modules &gt; \</p><p style="TEXT-INDENT: 2em;">                $(PRJROOT)/images/modules-2.4.18-rmk5/lib/modules/2.4.18-rmk5/modules.dep</p><p style="TEXT-INDENT: 2em;">其中 –k用来指定未压缩的内核映像，-F用来指定系统对映文件，-b用来指定内核需要建立依存关系的模块的基本目录。</p><p style="TEXT-INDENT: 2em;"> </p><p style="TEXT-INDENT: 2em;">十一、根文件系统</p><p style="TEXT-INDENT: 2em;">/etc 系统配置文件，包括启动文件</p><p style="TEXT-INDENT: 2em;">/usr 在第二层包含对大多数用户都有用的大量应用程序和文件，包括X服务器</p><p style="TEXT-INDENT: 2em;">/var 监控程序＆工具程序所存放的可变数据</p><p style="TEXT-INDENT: 2em;">存放二进制文件的目录主要有四个：</p><p style="TEXT-INDENT: 2em;">/bin  用户和系统管理员必备的二进制文件</p><p style="TEXT-INDENT: 2em;">/sbin 管理员必备、一般用户根本不会用到</p><p style="TEXT-INDENT: 2em;">/usr/bin 不是一般用户必备的文件</p><p style="TEXT-INDENT: 2em;">/usr/sbin 不是系统管理员必备的文件</p><p style="TEXT-INDENT: 2em;">根文件系统建立步骤：</p><p style="TEXT-INDENT: 2em;">mkdir bin dev etc lib proc sbin tmp usr var</p><p style="TEXT-INDENT: 2em;">chmod 1777 tmp //开启sticky位，可确保/tmp目录底下建立的文件及文件夹自由属主才有删//除权</p><p style="TEXT-INDENT: 2em;">mkdir usr/bin /usr/lib /usr/sbin</p><p style="TEXT-INDENT: 2em;">mkdir var/lib var/lock var/log var/run var/tmp</p><p style="TEXT-INDENT: 2em;">chmod 1777 var/tmp</p><p style="TEXT-INDENT: 2em;"> </p><p style="TEXT-INDENT: 2em;">十二、链接库glibc</p><p style="TEXT-INDENT: 2em;">共享链接库：libLIBRARY_NAME-GLIBC_VERSION.so,如数学链接库：libm-2.2.3.so</p><p style="TEXT-INDENT: 2em;">主修订版本的符号链接：libLIBRARY_NAME.so.MAJOR_REVISION_VERSION，如：libc.so.6</p><p style="TEXT-INDENT: 2em;">与版本无关的符号链接指向主修订版本的符号链接：</p><p style="TEXT-INDENT: 2em;">  libLIBRARY_NAME.so  例如，libm.so指向libm.so.6，而libm.so.6实际指向libm-2.2.3.so</p><p style="TEXT-INDENT: 2em;">静态链接库包文件：libLIBRARY_NAME.a</p><p style="TEXT-INDENT: 2em;">uClibc包含若干链接库，只会实现ld、libc、libcrypt、libdl、libm、libpthread、libresolv和libutil，可以做为glibc的代替品</p><p style="TEXT-INDENT: 2em;"> </p><p style="TEXT-INDENT: 2em;">十三、BusyBox、TinyLogin</p><p style="TEXT-INDENT: 2em;">必要的dev文件包括：mem、null、zero(以null byte为数据来源)、random、tty0、tty1、ttyS0、tty、console。建立方法如下：mknod –m 600(600是权限) mem c 1 1</p><p style="TEXT-INDENT: 2em;">除了建立基本设备文件以外，还需要必要的/dev符号连接。</p><p style="TEXT-INDENT: 2em;">链接名称          链接对象      </p><p style="TEXT-INDENT: 2em;">fd               /proc/self/fd</p><p style="TEXT-INDENT: 2em;">stdin              fd/0</p><p style="TEXT-INDENT: 2em;">stdout             fd/1</p><p style="TEXT-INDENT: 2em;">stderr              fd/2</p><p style="TEXT-INDENT: 2em;">BusyBox 实现了许多命令，可以修改配置，移除用不到的命令。提供的shell为ash、lash或msh。安装Busybox的命令：</p><p style="TEXT-INDENT: 2em;">以uclibc来编译：</p><p style="TEXT-INDENT: 2em;">make TARGET_ARCH=arm  CROSS=arm-uclibc &gt;PREFIX=$(PROJECT)/rootfs all install</p><p style="TEXT-INDENT: 2em;">修改/etc/profile文件后</p><p style="TEXT-INDENT: 2em;">set path</p><p style="TEXT-INDENT: 2em;">PATH=/bin:/sbin:/usr/bin:/usr/sbin</p><p style="TEXT-INDENT: 2em;">export PATH</p><p style="TEXT-INDENT: 2em;">TinyLogin：将许多登录工具程序放在单个二进制文件中，通常与BusyBox并用。可在<a href="http://tinylogin.busybox.net/" rel="nofollow">http://tinylogin.busybox.net/</a> 找到相关资料</p><p style="TEXT-INDENT: 2em;">安装方法：</p><p style="TEXT-INDENT: 2em;">以glibc来编译：make CROSS=arm-linux- PREFIX=$(PROJECT)/rootfs all</p><p style="TEXT-INDENT: 2em;">以uclibc来编译：make CROSS=arm-uclibc PREFIX=$(PROJECT)/rootfs all</p><p style="TEXT-INDENT: 2em;">embutils是针对unix命令提供的一组经过简化和优化的替代品，和BusyBox不同，embutils只能静态链接到diet lib，diet libc已经很小了，所有最后整体也很小，但从整体看，和busybox差不多。</p><p style="TEXT-INDENT: 2em;">定制应用程序</p><p style="TEXT-INDENT: 2em;">如果应用程序包含了相对较少的二进制文件，则将它放在/bin目录下也许是最好的选择。</p><p style="TEXT-INDENT: 2em;">如果应用程序包含了一组错综复杂的二进制文件，并且可能包含数据文件，可以考虑为他们的根文件系统中新增一个目录，注意修改PATH，以便纳入该目录路径。</p><p style="TEXT-INDENT: 2em;">系统初始化『可以参考《Take Command:Init》，<a href="http://www.linux.it/kerneldocs/init/" rel="nofollow">http://www.linux.it/kerneldocs/init/</a> 』</p><p style="TEXT-INDENT: 2em;">标准init套件:运行级别：0（终止系统运行）、1（单一用户模式，不需要登录程序）、2（多用户模式，不支持NFS，但需要登录程序）、3（多用户模式，使用命令行形式登录程序）、4（不使用）、5（X11，使用图形界面登录）、6（重新启动系统）</p><p style="TEXT-INDENT: 2em;">BusyBox的init工作流程：为init设置信号处理进程、初始化控制台、剖析inittab文件and /etc/inittab文件、执行系统初始化命令行、执行所有会导致init暂停的inittab命令（动作类型：wait）、执行所有仅执行依次的inittab命令（动作类型：once）</p><p style="TEXT-INDENT: 2em;">Minit（embutils和diet libc提供的一个小型init程序）</p><p style="TEXT-INDENT: 2em;">.</p><p style="TEXT-INDENT: 2em;"></p><p style="TEXT-INDENT: 2em;"></p><p style="TEXT-INDENT: 2em;">十四、存储设备管理</p><p style="TEXT-INDENT: 2em;">1、要在目标板上使用MTD子系统，需要配置内核，安装相关工具，以及在/dev目录中建立适当的条目。</p><p style="TEXT-INDENT: 2em;">2、在主机配置内核时，把所有MTD子系统选项都设成模块便于测试不同的设备设置。对目标板来说，用来支持固态存储设备的所有选项都必须建立成内核的一部分，而不是建立模块，否则目标板将无法从固态存储设备安装它的根文件系统。</p><p style="TEXT-INDENT: 2em;"> </p><p style="TEXT-INDENT: 2em;">3、与磁盘或DOC（DiskOnChip,M-Systems公司）设备（广泛用于X86为基础的嵌入式linux系统中）不同，不能使用fdisk或pdisk之类的工具对CFI flash设备进行分区，因为分区信息通常无法存储在CFI flash设备上，分区信息会硬编码在mapping驱动程序里，并且会在设备初始化期间向MTD子系统注册。 </p><p style="TEXT-INDENT: 2em;">根文件系统配置用得时候再参考</p><p style="TEXT-INDENT: 2em;"> </p><p style="TEXT-INDENT: 2em;"> </p><p style="TEXT-INDENT: 2em;">扩展问题：</p><p style="TEXT-INDENT: 2em;">1、  什么是回调函数？内在机制如何？与钩子函数有何区别？</p><p style="TEXT-INDENT: 2em;">当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数。回调函数在windows编程使用的场合很多，比如Hook回调函数：MouseProc,GetMsgProc以及EnumWindows,DrawState的回调函数等等</p><p style="TEXT-INDENT: 2em;">回调函数是由开发者按照一定的原型进行定义的函数</p><p style="TEXT-INDENT: 2em;">回调函数并不由开发者直接调用执行</p><p style="TEXT-INDENT: 2em;">回调函数通常作为参数传递给系统API，由该API来调用。</p><p style="TEXT-INDENT: 2em;">回调函数可能被系统API调用一次，也可能被循环调用多次。</p><p style="TEXT-INDENT: 2em;">         回调函数主要用于一些比较费时的操作,或响应不知道何时将会发生的事件,回调函数提供了一种异步的机制,相对于同步执行,提高了效率，Windows 系统还包含着另一种更为广泛的回调机制，即消息机制，编译器有几种调用规范。如在Visual C++中，可以在函数类型前加_cdecl，_stdcall或者_pascal来表示其调用规范（默认为_cdecl）。C++ Builder也支持_fastcall调用规范。调用规范影响编译器产生的给定函数名，参数传递的顺序（从右到左或从左到右），堆栈清理责任（调用者或者被调用者）以及参数传递机制（堆栈，CPU寄存器等）。</p><p style="TEXT-INDENT: 2em;">   钩子实际上是一个处理消息的程序段，通过系统调用，把它挂入系统。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。对每种类型的钩子由系统来维护一个钩子链，最近安装的钩子放在链的开始，而最先安装的钩子放在最后，也就是后加入的先获得控制权。要实现Win32的系统钩子，必须调用SDK中的API函数SetWindowsHookEx来安装这个钩子函数，这个函数的原型是</p><p style="TEXT-INDENT: 2em;">HHOOK   SetWindowsHookEx(int   idHook,HOOKPROC   lpfn,HINSTANCE   hMod,DWORD   dwThreadId);，其中，第一个参数是钩子的类型；第二个参数是钩子函数的地址；第三个参数是包含钩子函数的模块句柄；第四个参数指定监视的线程。如果指定确定的线程，即为线程专用钩子；如果指定为空，即为全局钩子。其中，全局钩子函数必须包含在DLL（动态链接库）中，而线程专用钩子还可以包含在可执行文件中。得到控制权的钩子函数在完成对消息的处理后，如果想要该消息继续传递，那么它必须调用另外一个SDK中的API函数CallNextHookEx来传递它。钩子函数也可以通过直接返回TRUE来丢弃该消息，并阻止该消息的传递。 </p><p style="TEXT-INDENT: 2em;">钩子函数，只是回调函数的一个特例。习惯上把与SetWindowsHookEx函数一起使用的回调函数称为钩子函数。也有人把利用VirtualQueryEx安装的函数称为钩子函数，不过这种叫法不太流行。</p><p style="TEXT-INDENT: 2em;">可以参考以下文章：&lt;异步消息的传递－回调机制&gt; <a href="http://www.ibm.com/developerworks/cn/linux/l-callback/index.html" rel="nofollow">http://www.ibm.com/developerworks/cn/linux/l-callback/index.html</a></p><p style="TEXT-INDENT: 2em;"></p></div><div style="height:32px;text-align:left;">阅读(638)| 评论(0)</div><div style="height:40px;"><div><span title="分享到LOFTER"> </span> <span title="分享到新浪微博"> </span> <span title="分享到QQ空间"> </span> <span title="分享到腾讯微博"> </span><div title="分享到微信"><div><img src="深入系列_files/Image [7].jpg" type="image/jpeg" style="height: auto;"/></div></div><div title="分享到易信"><div><img src="深入系列_files/Image [8].jpg" type="image/jpeg" style="height: auto;"/></div></div></div><div>喜欢 推荐 转载</div></div><div> 
<div><a href="http://kjxf2008.blog.163.com/blog/static/273835902008215548957/">电子逻辑电路</a></div>
 
<div><a href="http://kjxf2008.blog.163.com/blog/static/2738359020086510155526/">光耦和三极管</a></div></div><div style="visibility: hidden; width: 0px; height: 0px; overflow: hidden;"><div><img src="深入系列_files/Image [9].jpg" type="image/jpeg" style="height: auto;"/></div><div><a href="http://blog.163.com/wufeng5144/" target="_blank"><img src="深入系列_files/Image [10].jpg" type="image/jpeg" alt="wufeng5144" style="height: auto;"/></a><div><a href="http://blog.163.com/wufeng5144/" target="_blank"></a></div></div><div><a href="http://blog.163.com/jiangsenzz/" target="_blank"><img src="深入系列_files/Image [11].jpg" type="image/jpeg" alt="快乐小孩" style="height: auto;"/></a><div><a href="http://blog.163.com/jiangsenzz/" target="_blank"></a></div></div><div><a href="http://blog.163.com/superboy888pq/" target="_blank"><img src="深入系列_files/Image [12].jpg" type="image/jpeg" alt="superboy888pq" style="height: auto;"/></a><div><a href="http://blog.163.com/superboy888pq/" target="_blank"></a></div></div><div><a href="http://blog.163.com/rjwbgy/" target="_blank"><img src="深入系列_files/Image [13].jpg" type="image/jpeg" alt="rjwbgy" style="height: auto;"/></a><div><a href="http://blog.163.com/rjwbgy/" target="_blank"></a></div></div><div><a href="http://blog.163.com/erledelove/" target="_blank"><img src="深入系列_files/Image [14].jpg" type="image/jpeg" alt="erledelove" style="height: auto;"/></a><div><a href="http://blog.163.com/erledelove/" target="_blank"></a></div></div><div><a href="http://blog.163.com/caoguanghuineu/" target="_blank"><img src="深入系列_files/Image [15].jpg" type="image/jpeg" alt="caoguanghuineu" style="height: auto;"/></a><div><a href="http://blog.163.com/caoguanghuineu/" target="_blank"></a></div></div><div><a href="http://blog.163.com/anclover@126/" target="_blank"><img src="深入系列_files/Image [16].jpg" type="image/jpeg" alt="anclover@126" style="height: auto;"/></a><div><a href="http://blog.163.com/anclover@126/" target="_blank"></a></div></div><div><a href="http://blog.163.com/miss_spring/" target="_blank"><img src="深入系列_files/Image [17].jpg" type="image/jpeg" alt="miss_spring" style="height: auto;"/></a><div><a href="http://blog.163.com/miss_spring/" target="_blank"></a></div></div></div><div><h4 style="padding:0 0 0 10px;text-align:left;">在LOFTER的更多文章</h4></div><div><h4>评论</h4><a name="blogComment"></a><div>  登录后你可以发表评论，请先登录。登录&gt;&gt;</div></div><div> </div><div> </div><div> </div><div> </div><div><div><a href="http://yxp.163.com/" rel="nofollow" target="_blank">我的照片书</a> - <a href="http://blog.163.com/public/theme/" rel="nofollow" target="_blank">博客风格</a> - <a href="http://blog.163.com/services/wapblog.html" rel="nofollow" target="_blank">手机博客</a> - <a href="http://www.lofter.com/app?act=qbboke_20150209_02" rel="nofollow" target="_blank">下载LOFTER APP</a> - <a>订阅此博客</a></div><p>网易公司版权所有 ©1997-2017</p></div><div style="top: 100px; left: 200px;"><div style="bottom: -300px;"><div><a href="http://kjxf2008.blog.163.com/blog/static/27383590200842212930656/#" title="关闭"></a></div></div></div><div style="visibility: visible; opacity: 1;"><div><a href="http://www.lofter.com/view?from=blog" target="_blank"></a></div><div><a href="http://www.lofter.com/?index163Image=1496234167208&amp;newloginentry=1&amp;from=blog" target="_blank"><img src="深入系列_files/Image [18].jpg" type="image/jpeg" style="height: auto;"/></a><a href="http://www.lofter.com/?index163Image=1496234182326&amp;newloginentry=1&amp;from=blog" target="_blank"><img src="深入系列_files/Image [19].jpg" type="image/jpeg" style="height: auto;"/></a></div><div><a href="http://www.lofter.com/?act=qbboketanchuang_20150109_02&amp;newloginentry=1" target="_blank"> </a></div></div></span>
</div>
<hr>
<a name="776"/>

<div>
<span><div><b>学会如何设计和构造一个属于自己的微处理器；这些基本技能将为设计其他数字系统奠定坚实的基础。</b></div><div><br/></div><div><b>逻辑门</b>：接受0和1作为输入，产生0和1作为输出；</div><div><b>模块</b>：录用这些逻辑门构造加法器、存储器等；</div><div><br/></div><div>数字系统的一个重要特点是其构造模块非常简单：仅包括0和1；相反设计者最大的挑战是如何将这些简单的部件组合起来构成复杂的系统；</div><div>因此如何控制复杂性是一个贯穿的主题。</div><div><b><br/></b></div><div><b>控制复杂性的艺术</b></div><div>抽象：隐藏不重要的细节。一个系统可以从多个不同层面进行抽象。</div><div>约束：对设计选择的一种内在限制，通过这种限制可以更有效的在更高抽象层次上工作。使用可互换部件是约束的一种常见应用。通过将部件限定为一个误差允许范围的标准集合，可以快速的完成系统的设计和构建。</div><div>通过数字电路的约束规则，可以很容易的将组件组合成复杂的系统。</div><div>三Y原则：层次化、模块化、规整化</div><div>层次化：将系统划分为若干模块，然后更进一步划分每个模块直到这些模块可以很容易理解；</div><div>模块化：所有的模块有定义良好的功能和接口，以便于它们之间可以很容易得相互连接而不会产生意想不到的副作用；</div><div>规整化：在模块之间寻求一致，通用模块可以重复使用多次，以便于减少设计不同模块的数量。可互换部件即使如此。</div><div><br/></div><div><br/></div><div><b>数字抽象1：</b></div><div><br/></div><div>数字抽象的优势在于设计者只关注0、1，而忽略布尔变量的物理表示。编程人员不需要了解计算机硬件的细节就可以工作；当然对硬件细节的理解使得程序员可以针对特定的计算模型来优化软件。</div><div>一个单独位没有信息；但是一组位（bit） 可以表示数字，也可以表示字母和程序。</div><div><br/></div><div>物理变量：连续和离散之分。</div><div>状态：高电压-1；低电压-0；</div><div>信息量D：一个有N个不同状态的离散值变量的信息量由位（bit）度量；关系是：D=log2N 位；</div><div>数字系统：二进制和其他进制之分。 布尔逻辑：针对二进制变量进行逻辑操作的系统；</div><div><br/></div><div>数制：</div><div>十进制、二进制、十六进制</div><div><br/></div><div>字节、半字节和全字：一组位</div><div>8位、4位；微处理器处理的一块数据称为字；字的大小取决于微处理器的架构。比如64位微处理器针对64位的字进行操作。</div><div>最低有效位（权：1）；最高有效位（权：X）；当然，也有最低有效字节；最高有效字节</div><div><br/></div><div>二进制加法</div><div>进位；数字系统常常对固定长度的数字进行操作，如果加法的结果太大，超出了数字的表示范围，将产生溢出（进位不合法）；因此通过检查最高一列是否有进位来判断是否有溢出。</div><div><br/></div><div>有符号的二进制数：带符号位的原码和补码</div><div><br/></div><div>带符号位的原码：在一个N位带符号位的原码数中最高位为符号位，剩下的N-1位为数值（绝对值）。符号位为0表示正数，1表示负数。</div><div>补码：二进制补码最高位的权是-2<span style="font-size: 11px;">N-1</span>，而不是2N-1。其他位的表示方法与无符号二进制数相同。可以使用加法以及0的表示唯一。</div><div><br/></div><div>逻辑门</div><div>使用二进制变量来表示信息，当然也有对这些二进制变量进行操作的数字系统。逻辑门就是如此。</div><div>输入和输出的关系由真值表或是布尔表达式来描述。</div><div>非门、缓冲器、与门、或门、其他二输入门以及多输入门。单输出。</div><div><br/></div><div><b>数字抽象2：</b></div><div>设计者必须找到一种将连续变量和离散变量联系在一起的方法。</div><div><br/></div><div>电源电压：</div><div>最低电压0V，称为地；最高电压来自电源，一般为5V；但是可以降到3.3V、2.5V、1.8V、1.5V、1.2V等</div><div><br/></div><div>逻辑电平和噪声容限：</div><div>图1-23</div><div><br/></div><div>直流电压的传输特性和静态约束：</div><div><br/></div><div>逻辑门的底层：COMS晶体管的组合</div><div><br/></div><div>功耗：单位时间内所消耗的能量。</div><div>分动态功耗和静态功耗。动态功耗是信号在0和1之间变化过程中电容充电所耗费的能量；静态功耗是挡信号不发生变化时系统处于空闲这状态下的功耗。</div><div><br/></div><div><b>手册使用</b></div><div><br/></div></span>
</div>
<hr>
<a name="788"/>

<div>
<span><div>数字电路中，电路是一个处理离散值变量的网络。</div><div><br/></div><div>电路可以看做是黑盒，包括：</div><ul><li>输入端（1 or more 离散值）</li><li>输出端（1 or more 离散值）</li><li>功能规范（f : input ~output）</li><li>时序规范（描述输入改变时输出响应的延迟）</li></ul><div><br/></div><div>电路由节点和元件组成。</div><ul><li>元件是子电路</li><li>节点是一段导线，通过电压传递离散值信号
<ul><li>输入节点</li><li>输出节点</li><li>内部节点</li></ul></li></ul><div><br/></div><div>数字电路分为组合电路和时序电路。</div><ul><li>组合电路：输出仅取决于当前输入值（无记忆）</li><li>时序电路：输出取决于当前输入值和之前输入值（有记忆）</li></ul><div><br/></div><div>一个简单的函数通常有多重实现。可以根据配置和设计约束选定模块来实现组合电路。这些约束包括面积、速度、功率 和设计时间。</div><div><br/></div><div>组合电路的构成规则：</div><ol><li>每个电路元件本身都是组合电路</li><li>每个电路节点或是一个电路的输入，或是连接到外部电路的一个输出</li><li>电路不包含回路：经过电路的每条路径最多只能经过每个电路节点一次</li></ol><div><br/></div><div>控制复杂度：</div><ul><li>应用抽象和模块化原则将电路视为一个明确定义了接口和功能的黑盒</li><li>应用层次化原则由较小电路元件构建复杂电路</li><li>组合电路的构成规则应用约束原理</li></ul><div><br/></div><div>组合电路的功能规范常表示为：真值表和布尔表达式。</div><ul><li>由真值表得到布尔表达式</li><li>使用布尔代数和卡诺图来化简表达式</li><li>通过逻辑门来实现表达式</li><li>分析电路的速度</li></ul><div><br/></div><div>变量或它的反称为项；</div><div>项的AND称为乘积项（蕴含项）；包含全部输入变量的乘积项称为最小项；</div><div>项的OR称为求和项；包含全部输入变量的求和项称为最大项。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div>
<hr>
<a name="790"/>

<div>
<span><div><span style="font-size: 15px;"><b>引子</b></span></div><div><br/></div><div>状态：时序逻辑从先前的输入中提取的信息；它由一组状态变量位构成。宽泛的说是，状态变量包含了所有解释电路未来行为的所需的先前信息。</div><div>初始状态：当第一次给时序电路加电时，它的初始状态是未知的且不可预测；电路的每一次初始状态都可以不同。</div><div><br/></div><div>存储器件的基本模块是一个：双稳态元件。一对反相器交叉耦合即可组成简单的双稳态元件，它没有输入、只有两个输出；由于交叉耦合反相器的输出有两种稳定状态 0或1，所以该电路称为双稳态。</div><div><br/></div><div>交叉耦合，即I1的输入是I2的输出、反之亦然。</div><div><br/></div><div>稳态：如果输出仅且唯一是0或1这两个值，则电路是稳定的。</div><div>非稳态：如果输出既是0又是1，则电路是非稳定的。</div><div>亚稳态：如果输出大约处于0~1之间的一半，则电路是亚稳态的。</div><div><br/></div><div>延迟：每个元件都有自己的 工作时间/每段信息的 传输都需要时间，而这些时间在通路的表现是延迟。延迟是可以累积的，这种现象有利有弊（不敏感）。</div><div>相位：在时序电路中，相位也是有二进制 0/1表示的。所谓反相，就是取反。</div><div>信息位：具有N个稳态的元件可以表示logN位的信息；双稳态元件可以存储1位的信息，其状态包含在二进制状态变量Q中。</div><div><br/></div><div>锁存器和触发器：提供了可以控制状态变量值的输入。</div><div><br/></div><div>SR锁存器：由一对交叉耦合的或非门组成。所谓“控制状态变量值的输入”，是因为可以置位或复位输出（高电平有效）。值得注意的是：</div><ul><li>R/S同时有效：没有意义。</li><li>R/S同时无效：Q保持原来的值不变，或是称为状态不变。</li><li>R/S混淆时间和内容。</li><li>输入的全部历史可以由状态变量Q来解释；但无论过去是否置位/复位，都需要通过最近一次的置位/复位来确定SR锁存器的未来行为。</li><li>抽象与模块：有多钟方法可以构造SR锁存器（不同的逻辑门或是晶体管），但是只要满足其对应的真值表和逻辑关系的电路元件即可称为SR锁存器。</li></ul><div><br/></div><div>D锁存器：当输入有效时（一般高电平有效），不仅需要确定 内容是什么，而且还需要确定 何时改变。值得注意的是：</div><ul><li>使内容和时间分离：数据输入D，控制下一个状态的值；时钟输入CLK，控制状态发生改变的时刻。</li><li>重点强调一下，时钟可以控制何时数据通过锁存器。</li><li>CLK为0，Q保持原来的值不变；CLK为1，Q等于D（一般高电平有效）。以CLK的高低电平决定触发条件，因而称为电平敏感。</li></ul><div><br/></div><div>透明：导通状态（D锁存器类似于缓存器）。</div><div>不透明：阻塞状态（D锁存器保持原来的状态不变、类似于存储器）。</div><div><br/></div><div>D触发器：由 反向 时钟控制的两个背靠背的主从D锁存器组成；D触发器又称为主从触发器、正边沿触发器等。 值得注意的是：</div><ul><li>从D到Q之间通路，总有一个阻塞/不透明的锁存器；因而D触发器在时钟上升沿将D复制到Q，在其他时间D触发器保持原来的状态。</li><li>计算D触发器的晶体管数量：（传输门实现效率更高）
<ul><li>与非门/或非门：4</li><li>非门：2</li><li>与门，一个非门和一个与非门组成：6</li><li>SR锁存器，两个或非门：8</li><li>D锁存器，一个SR锁存器、两个与门、一个非门组成：22</li><li>D触发器，两个D锁存器和一个非门组成：46</li></ul></li></ul><div><br/></div><div>寄存器：N位寄存器由共享一个公共CLK输入的N个触发器组成；使寄存器的所有位可以同时更新。值得注意的是：</div><ul><li>寄存器是触发器的集合，用以扩展数据总线传输的位数。</li><li>寄存器是后续状态机的关键组件。</li></ul><div><br/></div><div>其他触发器</div><ol><li>带使能端的触发器：增加一个enabled的输入，用于确定在时钟沿是否载入数据。当我们需要在某些时刻（而不是在每个时钟沿）更新状态时，该触发器非常有用。实现方式可以有两种：EN控制额外的输入复用器；时钟被门控-EN。</li><li>带复位端的触发器：增加一个reset的输入，用于确定状态Q是否为0。当我们需要将所有触发器设置到已知状态（0），该触发器是非常有用的。当然，带置位端的触发器也是如此。</li><li>带置位/复位功能的触发器也可以带有使能输入端；当然，也可以组成N位寄存器。</li></ol><div><br/></div><div>门控：利用与门或是其他门的特性对信号进行控制的方法，比如使用与门的特性（只要一端输入为0，输出即为0）。</div><div>时钟门控：一般而言，在时钟上执行逻辑是不推荐的；可能使时钟延迟并导致时序错误。</div><div>输入门控：同上，只不过对象换成D。</div><div><br/></div><div>异步复位（置位）：reset有效就可以对其复位，而与CLK无关。</div><div>同步复位（置位）：CLK &amp;&amp; reset有效方可对其复位。这种电路中，时钟具有唯一的控制权，不可“侵犯 ”。“侵犯”包括延迟和相位的改变等。</div><div><br/></div><div>晶体管级锁存器和触发器的设计：</div><div><br/></div><div><span style="font-size: 15px;"><b>同步逻辑设计</b></span></div><div><b><br/></b></div><div>一些问题的时序电路</div><ol><li>非稳态电路：环形振荡器（由三个反相器环组成）；其震荡周期取决于每个反相器的传播延迟；而传播延迟又取决于制造参数和工作参数。因此其周期很难预测。</li><li>竞争电路：异步电路中经常会出现竞争条件而难以掌握。之所以出现，是因为其电路的行为取决于两条通过逻辑门的路径哪条更快。这种错误极难检查。一个例子就是时钟门控。</li></ol><div><br/></div><div>同步时序电路</div><ul><li>组合电路没有环路和竞争，输出是随输入的确定值。但是包含环路的时序电路存在不良的竞争以及不稳定的行为。</li><li>因此，一种解决方法是：在反馈路径中插入寄存器来断开反馈环路；于是，时序电路将转变为组合逻辑电路和寄存器的集合。寄存器包含状态，而这些状态仅仅在时钟沿到达时发生改变；即状态同步于时钟。</li><li>常见的同步时序电路：有限状态机和流水线。</li></ul><div>组成规则：</div><ul><li>每一个电路元件或是寄存器或是组合电路。</li><li>至少有一个电路元件是寄存器。</li><li>所有寄存器接受同一个时钟沿。</li><li>每个反馈环路至少插入一个寄存器。</li><li>流水线变种：也可能没有反馈环路。</li></ul><div><br/></div><div>形式化定义：通过电路的输入、输出、功能规范、时序规范可以定义一个电路。</div><div>当前状态：目前系统的状态S。</div><div>下一状态：下一个时钟沿，系统将进入的状态S'。</div><div>功能规范：在当前状态和输入的组合下，每个输出的下一个值。</div><div>时序规范：上界时间、下界时间（从时钟沿开始直到输出改变的时间段）；建立时间、保持时间（相对于时钟沿使输入达到稳定的时间段）。</div><div><br/></div><div>异步时序电路：当两个不同时钟的系统之间进行通信 或是 在任意时刻接受输入（并发现象），异步电路非常重要。</div><ul><li>宽泛的说是，进程通信和中断也是如此，因此需要内核同步；内核同步方式有：......。</li><li>可以推断出：异步时序电路仅仅是输入电路，但是处理电路一定是同步时序电路（采用源同步或是增加FIFO是两种熟悉的方式）。但至于输出电路就不一定。</li></ul><div><br/></div><div>有限状态机FSM</div><div>具有k位寄存器的电路可以处于2^k 种状态中的某一种唯一状态。有限状态机提供了系统的方法来设计给定功能规范的同步时序逻辑电路。</div><div><br/></div><ul><li>有限状态机有M个输入、N个输出和k位状态以及一个时钟信号和一个可选的复位信号。</li><li>两个组合逻辑块：下一个状态逻辑和输出逻辑；时序模块：存储状态的寄存器。</li><li>在每一个时钟沿，有限状态机可以进入下一个状态（根据当前状态和输入计算而来）。</li></ul><div><br/></div><div>FSM分有两类：</div><ul><li>Moore型：输出仅仅取决于当前状态。</li><li>Mealy型：：输出取决于当前状态和当前输入。</li></ul><div><span style="font-size: 15px;"><br/></span></div><div><span style="font-size: 15px;"><b>时序逻辑的时序规范</b></span></div><div><br/></div><div>引子：首先，触发器在时钟沿将输入 D复制到输出Q；该过程可称为在时钟沿对D采样。如果在时钟沿上D是稳定状态，那么该动作可以清晰的定义；但是如果D在时钟沿上发生变化，则会发生什么呢？</div><div>结论：时序元件在时钟沿有孔径时间，在孔径时间内输入必须保持稳定，触发器才能产生明确定义的输出。</div><div><br/></div><div>动态约束：正如静态约束限制使用在禁止区域外的逻辑电平，动态约束限制使用在孔径时间处改变的信号。</div><ul><li>最小延迟</li><li>传播延迟</li><li>孔径时间
<ul><li>时钟沿前的建立时间</li><li>时钟沿后的保持时间</li></ul></li></ul><div><br/></div><div>抽象：由动态约束，可以认为时间是基于时钟周期的离散单元，等效于信号电平的离散0/1。在周期内信号可以有毛刺，也可以反复震荡；但是我们只关心时钟周期结束时的终值，并将其设置为稳定值。</div><div>因此，<b>以A[n]代替A(t)是很自然的事</b>。其中A[n]表示第n个时钟周期结束时信号A的值，A(t)表示t时刻A的值。</div><div><br/></div><div>引入的问题1：为了稳定信号，时钟周期应该足够长，但是这限制了系统的速度；而且时钟绝不会准确的同时到达所有触发器（称之时钟偏移），这进一步增加了必要的时钟周期。</div><div>引入的问题2：真实系统中，动态约束往往不能满足。考虑异步输入下，在时钟沿很容易捕捉到一个亚稳态值；而解决这种现象的方法是在异步输入后加上一个同步器（同步器产生非法逻辑值的概率很小）</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 