Shell 脚本高级指南
==============
章节
----------------------

* **第一章：背景知识**
* **第二章：入门**
* **第三章：查找与替换**
* **第四章：文本处理工具**
* **第五章：管道的神奇魔力**
* **第六章：变量，判断，重复动作**
* **第七章：输入/输出，文件与命令执行**
* **第八章：产生脚本**
* **第九章：awk的惊人表现**
* **第十章：文件处理**
* **第十一章：扩展实例**
* **第十二章：拼写检查**
* **第十三章：进程**
* **第十四章：Shell可移植性**
* **第十五章：安全的Shell脚本：起点**

	* **附录A：编写手册页**
	* **附录B：文件与文件系统**
	* **附录C：重要的UNIX命令**

##第一章：背景知识##
###摘要###
* 善加利用UNIX所提供的工具
	* UNIX何处开发
	* UNIX如何开发
	* UNIX的设计动机
* 软件工具的设计原则：简洁的Shell程序和正确使用UNIX工具

####UNIX简史####
UNIX是在何种环境诞生的，以及如何影响软件工具的设计。
自由的开发环境：

	将设备视为文件，以及将Shell与操作系统独立。
	务实的设计模式（削弱交互性对话）。
	简单就是力量（设计与解决问题）。
	
标准的生产环境：

	工具程序之间存在诸多不一致。
	诸多工具程序具有缺陷。
	程序并未经过彻底测试，执行过程中易遭受破坏。如：核心转储。
	系统的文档极为简单。现：系统文档分为两个部分：参考手册和使用手册（已储备）。


1. UNIX早期不能运行大型程序。故完成复杂的工作需将其分割成更小的工作，再用程序分别实现。某些常见的工作最终成为标准工具。更小，更简单，更专用。

2. UNIX的使用多少采用半独立的工作方式：重复套用彼此间的程序（管道）。由于版本间的差异，将使工作复杂许多。重名也是很苦恼的。

3. 现：兼容POSIX标准，包括常用标准工具组与选项;C库，Shell语言;系统工具组与选项。当然SUS也是UNIX标准化的成果（将POSIX纳入子集），而它将成为编写工具与应用程序的必参文件。


##设计与编写软件工具的原则：（提供开发与使用UNIX工具集的指导方针）##
	
	* 一次做好一件事（最重要）：设计，编写，调试，维护以及生成文件都简易;使用更小，更专用于特定功能的程序。
	* 处理文本行，而不是二进制数据：文本行是UNIX的通用格式;其数据处理/传输相对简单，更有助于任何自定义工具与现存UNIX程序之间的结合。
	* 使用正则表达式：文本处理机制，可适度简化编写脚本的工作;POSIX仅提供两种正则表达式：（结合标准的库程序进行模式匹配的工作，以编写出专用的工具程序）用于与GREP一致的正则表达式（基本型BRE）,用于与EGREP一致的正则表达式（扩展型ERE）。
	* 默认使用标准输入/输出：让它们充当数据过滤器。
	* 避免喋喋不休：没有消息就是好消息。
	* 输出数据必须与可接受的输入格式一致：容易将一个程序的执行结果交给另一个程序处理。
	* 让工具去做困难的部分：充分利用可解决90%工作的现有程序，自己构建程序去做10%。
	* 构建特定工具前，先想想：你所要做的事，是否有其他人也需要做？这个特殊的工作是否有可能是某个一般问题的一个特例？如果是的话，请针对一般问题来编写程序。
	
**note:**重点放在文本（而非二进制）数据的处理和运用上。	
**note:**重点放在POSIX标准所定义的Shell语言与UNIX工具程序以及编写可移植的Shell脚本。	

##第二章：入门##
###原则###
1. 最好用对工具：当你需要程序语言协助完成工作时，不同的程序语言用于不同的需求。
2. Shell语言最常用于系统管理工作，或是用于结合现有的程序以完成小型的，特定的工作。
3. 一旦能完成工作，便可将用到的命令串在一起，放进一个独立的脚本里，此后直接执行脚本即可。
4. 若脚本有一定的通用性，便可将其作为黑盒。

####脚本语言与编译语言的差异####
* 编译语言：
	- 编译器（由编译器读入代码，并将源代码直接转换成目标代码，执行）。
	- 底层（处理字节，整数，浮点数或其他机器级对象）。
* 脚本语言：
	- 解释器（由解释器读入代码，并将其转换成内部形式，执行）。而解释器本身是一般的编译型程序。
	-  高层（处理文件与目录之类的对象）。
	- 交互方式。
**note:**
该选编译语言还是脚本语言，通常视应用程序的需求而定。
####为什么使用Shell语言？####

- 简单性：Shell是一个高级语言，通过它，你可以简洁的表达复杂的工作。
- 可移植性：使用POSIX所定义的功能，可以做到脚本无需修改就可以在不同的系统上执行。
- 开发容易：可以在短时间内完成一个功能强大且好用的脚本。

####一个简单小型的脚本####
**典型开发周期**

- 直接在命令行上测试。
- 找到能够完成工作的适当语法。
- 将其放进一个独立的脚本里，并为其设置执行的权限。
- 直接使用该脚本。
- 等到程序能够运行无误后，就可以将其移到个人的`bin`目录。

####自给自足的脚本：位于第一行的#！####

	Shell脚本通常一开始都是 #!（符合POSIX标准的Shell）。以下是几个初级陷阱：
	1. 对 #! 这一行的长度限制尽量不超过64个字符。考虑到短板效应与可移植性。**GNU/Linux最大长度是127。**
	2. 脚本是否具有可移植性取决于命令行部分（也就是要传递给解释器执行的程序）是否包含程序的完整路径名称。（一般情况下，使用Shell查找路径会使命令行部分简洁）。
	3. 在选项之后莫放置任何空白。
	4. 你需要知道解释器的完整路径名称。以针对不同厂商将相同的东西放在不同地方的问题（规避可移植性问题）。
	5. 在较旧的系统上，内核不具备解释#!的能力;有些Shell会自行处理。（这些Shell对于 #! 与紧跟的解释器的名称之间是否可以有空白，可能有不同的解释）。
	
####Shell的基本元素：适用于所有Shell脚本的基本元素####
- 命令与参数
	
	**Shell最基本的工作就是执行命令。**
	
>UNIX命令行的格式：
	1. 以空白隔开命令行的各个组成部分。
	2. 命令名称是命令行的第一个项目;通常后面紧跟选项（可选），接着任何额外的参数都会放在选项之后。
	3. 选项的开头是一个减号，后面紧跟字母;有可能需要加上参数。不需要参数的选项可以合并。
	4. 长选项的开头是一个减号还是两个减号，视程序而定。
	5. 分号可用来分割同一行里的多条命令。Shell会依次执行这些命令。
	6. 若使用&符号而不是分号，则Shell将在后台执行前面的命令。
	7. 以`#`开头的一行是一个注释。注释可以帮助其他人或是自己理解程序。
	
	Shell 识别三种基本命令（程序）：
	1. 内建命令：由Shell本身所执行的命令。
	2. Shell函数：功能健全的一系列程序代码，以Shell语言写成，他们可以像一般命令那样引用。
	3. 外部命令：由Shell的副本（新的进程）所执行的命令。
	
- 变量

	所有程序语言都会有变量，Shell也不例外。
	每个变量都有一个值，作为分配给变量的信息。在Shell的世界里，变量值可以是（而且通常是）空值（null）。这是常见，合理，好用的特性。
	Shell变量的名称构成遵循一般原则。而变量名称的字符长度和变量值并无限制，遵循不限制的设计原则。
	
	**变量赋值**的方法为：先写变量名称，紧接着=字符，最后是新值，中间完全没有任何空格。取值方法：需在变量名称前面加上$字符。当所赋予的值内含空格时，加上引号。
	
- 简单的echo输出：打印参数（参数之间以空格分割，默认以换行符结尾;它用于提示用户或是产生数据以供进一步处理）;支持转义字符;只要是使用最简单的形式，其可移植性不会有问题。echo详见30。
- 华丽的printf输出：`echo`的替代方案。

- 基本的IO重定向
	
	**标准输入输出（软件设计原则里最重要的概念）：**程序应该有数据的来源端，数据的目的端以及报告问题的地方，它们分别被称为标准输入，标准输出以及标准错误输出（设备即文件，数据）。当程序启动后，标准输入都已打开，且准备好供其使用。
	
	**过滤器：**读取标准输入，写入标准输出，并将错误信息传递给标准错误输出的程序。在登录后，UNIX便将这些默认安排成你的终端。
	
	**IO重定向：**通过与终端交互，或是在Shell脚本里设置，重新安排从哪里输入或向哪里输出。
	
	**重定向与管道：**以 < 改变标准输入（文件的原始数据不变）;以 > 改变标准输出（文件的创建与覆盖）;以 >> 改变标准输出（文件的创建与附加到文件的结尾处）;以 | 建立管道（将 program1 的标准输出修改为 program2 的标准输入），并将各类工具串在一起。
	
*使用UNIX工具程序时，不妨将数据想象成水管里的水。未经处理的水，将流向净水厂，经过各类滤器的处理，最后产生适合人类饮用的水。*

*同样，编写脚本时，通常已有某种输入格式的原始数据，而需要处理这些数据以产生结果。（处理一词表示很多意思，例如排序，格式化等等;当然，也有很多命令将其实现）。从最原始的数据开始，然后构造一条管道，一步一步地，管道中的每个阶段都会使数据接近想要的结果。并且可以将 < 与 > 想象成数据的漏斗，数据会从大的一端进入，由小的一端出来。*

*构造管道时，应该尝试将每个阶段的数据量变得更少。换句话说，如果你有两个步骤与先后次序无关，可以将会让数据量变少的那个步骤放在管道的前面，以提升脚本的整体性能。`tr`详见34。*

*特殊文件：`/dev/null`与`/dev/tty`(Shell编程)*
>/dev/null：位桶，回收站（传递到此文件的数据都会被系统丢掉）。也就是说，当程序将数据写到此文件时，表述它已成功完成写入数据的操作。如果你需要的是命令的退出状态，而非它的输出，此功能相当有用（例如测试一个文件是否包含某种模式）。而读取/dev/null会返回文件结束符号，此操作相对较少。
>/dev/tty：当程序打开此文件时，UNIX会自动将其重定向到一个终端，再与程序（包括stty：用来控制终端或窗口的各种设置）结合。终端包括实体的控制台，串行端口，或是一个通过网络与窗口登录的伪终端。这在程序必须读取人工输入时特别有用，但很少人将其用于产生错误信息。
	
- 基本命令（三种）的路径查找

*Shell会沿着查找路径`$PATH`来寻找命令。`$PATH`是一个以冒号分割的目录列表，你可以在列表所指定的目录中放置和寻找所要执行的命令。该命令可以是可执行文件，也可以是Shell脚本（当然，采用#!之后，从用户的角度看，二者并无不同）。*

**默认路径：**因系统而异（名称为`bin`的目录用来保存可执行文件）。
**自定义路径：**如果要编写自己的脚本，最好准备自己的`bin`目录来存放它们，并且让Shell能够自动找到。只要建立自己的`bin`目录，并将它加入`$PATH`中的列表即可。要永久生效，在`.profile文件`中把你的`bin`目录加入`$PATH`，而每次登录时Shell都将读取`.profile文件`。

>`$PATH`里的空项目表示当前目录。
空项目位于路径值中间，可以用两个连续的冒号来表示。
如果将冒号直接置于最前端或尾端，可以分别表示查找时最先查找或最后查找当前目录。
如果你希望将当前目录纳入查找路径，更好的做法是在`$PATH`中使用点号。
>空项目在可移植性上存在问题。一般来说，你根本就不应该在查找目录中放入当前目录，因为存在安全问题。

####访问Shell脚本的参数####

- 所谓的位置参数指的就是Shell脚本的命令行`参数（详见命令和参数一节）`。在Shell函数里，它们同时也可以是函数的参数。
- 各参数都由整数来命名（当它超过9，就应该用大括号把数字框起来）。
- 此外，通过特殊变量，还可以取得参数的总数，以及一次取得所有参数。
- 如何测试命令行参数数目，以及在参数数目不符时，如何采取适当的操作。

####国际化与本地化（略）####
####简单的执行跟踪####

想知道你的程序正在做什么，有个好方法，就是把执行跟踪的功能打开。这会使Shell显示每个被执行的命令。
**命令行方式：**

`sh -x 命令`

**脚本方式（复杂的）：**

* 打开：`set -x`
* 关闭：`set +x`

##第三章：文本查找与替换（编写Shell脚本时两个基本操作）##

- 文本查找：寻找含有特定文本的行。
- 文本替换：更换找到的文本。
- 字符串：虽然可以使用简单的`固定文本字符串`来完成很多工作，但是`正则表达式`能提供功能更强大的标记法（以单个表达式匹配各种实际的文本段）。

####查找文本####

以`*grep`程序匹配（查找）文本是相当方便的。在POSIX系统中，`*grep`可以在两种正则表达式风格中选择一种，或是执行简单的`固定文本字符串`匹配。

- `grep`：使用POSIX定义的基本正则表达式（BRE）。
- `egrep`：使用扩展正则表达式（ERE）。当然功能更为强大。
- `fgrep`：匹配`固定文本字符串`而非`正则表达式`。
- `grep`和`egrep`只能匹配单个正则表达式，而`fgrep`则可以匹配多个字符串。

**POSIX标准将以上三种版本整合成一个`grep`程序，它的行为是通过不同的`选项`加以控制。**

####简单的`grep`####

最简单的用法就是使用`固定字符串`（通过使用`-F`选项）。
事实上，只要匹配的模式里未含有正则表达式的`meta`字符，就可以默认如上。

####正则表达式：POSIX BRE与ERE的构造和匹配方法####
`grep`详见46。

> 正则表达式是 UNIX 使用工具和构建模型的基础。
深入的学习正则表达式是一件回报率很高的事。
使用正则表达式来完成具有可移植性的Shell脚本。

####什么是正则表达式？####

*正则表达式是一种表示方法，让你可以匹配特定准则的文本。（即：此表示法让你可以写一个表达式，选定或匹配多个数据字符串）。*

*很多UNIX程序都沿用某一种正则表达式形式来强化本身的功能：*

- 用来匹配**文本行**的`grep`工具族。
- 用来改变输入流的`sed`流编辑器。
- 字符串处理程序语言：awk,icon,perl,python,tcl。
- 文件查看程序（分页程序）：more,page,pg,less。
- 文本编辑器：ed行编辑器，标准vi屏幕编辑器，还有一些插件编辑器（emacs,jed,jove,vile,vim）。

*从根本上来说，正则表达式有两个基本组成部分：*

- 一般字符：任何没有特殊意义的字符。在某些情况下，特殊字符也可以视为一般字符。
- 特殊字符：常称为元字符（meta字符）。POSIX BRE与ERE的meta字符列表详见48或cala。

**POSIX方括号表达式**

*在方括号表达式中，除了字面上的字符外，另有额外的组成部分，包括：*

- 字符集：以`[:`与`:]`将关键字括起来的POSIX字符集。关键字描述各种不同的字符集，例如英文字母字符，控制字符等等。为配合非英语环境，POSIX标准强化其字符集范围（包含Unicode字符集标准），以匹配非英文字母字符。例如[a-z]只能匹配英文字母字符，但无法提供其他语种。 POSIX字符集详见cala。
- 排序字符：将多字符序列视为一个单位，以`[.`与`.]`将字符序列括起来。排序字符在系统所使用的特定locale上各有定义。其又称为字符序列功能（POSIX标准）：可用于在匹配及排序`字符串`时，将序列里的字符视为一个独立单位。
- 等价字符集：应视为等值的一组字符，以`[=`与`=]`括住。
- 以上三种构造都必须使用方括号表达式（即：最外层需此括住）。POSIX的字符集，排序字符以及等价字符集均取自于locale的名字元素。

####基本正则表达式（BRE）####

**匹配单个字符：以一般字符，转义的meta字符；以点号；以方括表达式（交叉混用）**

- 一般字符：未列于cala的字符，包括所有文字和数字字符，绝大多数的空格字符以及标点符号字符。（直观，唯一）。
- 转义的meta字符：让meta字符表示其字面含义时。
- 点号：任一字符。单个点号匹配单个字符的情况很少，通常与其他meta字符搭配使用，这一结合允许匹配多个字符。
- 方括号表达式：匹配单个字符。^放在字首表示取反的意思。连字符表示字符的范围。

*注意：*
>使用连字符表示字符的范围，是依据本地机器中的字符集的数值。因此字符集（ASCII或EBCDIC）的不同，会使可移植性受挫。不过问题不大（ASCII的支持很广）。

>POSIX字符集，则提供一种可移植性方式。`范围`使用的是各个字符在locale排序序列里所定义的位置，与机器字符集里的数值不相关。在新程序中激励使用POSIX字符集代替`连字符`。

**后向引用：模式复用**

*步骤：*
> 1. 将子模式包含在 `\(`与`\)`里。单个正则模式可包含最多9个子模式，且可为嵌套结构。
> 2. 在子模式之后使用`\n`，n介于1～9 之间。子模式的执行顺序从左至右，而相对应的`\n`的书写顺序从右至左。
> 后向引用在寻找重复字符（串）以及匹配引号时特别好用。

**匹配多个字符：单个表达式**

*方式：*
> 1. 最简单的方法就是把它们一个一个的列出来（连接）。仅适用于简短的正则表达式。
> 2. 使用修饰符meta字符。这类字符紧接在`匹配单个字符的正则表达式`之后，并将其改变为`匹配任意个同样字符的正则表达式`。最常用的修饰符是星号，表示匹配0或多个。

**注意**
修饰符本身没有限制，即不能要求其匹配`特定数目`的同样字符。
作为替代，区间表达式可以解决此类问题。它们紧接在`匹配单个字符的正则达式`之后，并将其改变为`匹配特定个同样字符的正则表达式`。其有三种形式。

**文本匹配锚点：脱字符号与货币符号**

锚点：在限制正则表达式匹配时，针对要被匹配的字符串的开始或结尾处进行匹配。换句话说就是，使用锚点可以匹配字符串的头或尾，但中间没门。

^与$同时使用：匹配单个字符串（或行）。特殊的是，^$用来匹配空的字符串（或行）。
^与$仅在BRE的起始与结尾处具有特殊用途。反之，若^与$出现在字符串中间，其表示的就是字面意思。

^需要注意与方括号表达式连用时的区别。

**BRE运算符优先级**
详见cala。

####扩展正则表达式（ERE）：更多的功能####

*BRE与ERE在大多数meta字符与功能应用上几乎一致，但是有些meta字符看起来相似，却具有完全不同的意义。*

**匹配单个字符：没有区别，一个例外：在awk里，其转义符号`\`仍有其特殊意义** 

**后向引用不存在：`\( \)仅是转义而已`，圆括号具有另外的特殊含义**

**匹配单个模式与多个正则模式**





















